<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint 2</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>. </li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	

</div>
<h2>Requirement Analysis</h2>
<div class="remark">
<em>clean</em>: Task per la pulizia dei tavoli, un tavolo sporco non può venire assegnato a nessun nuovo cliente. 
Il waiter deve eseguire una fase di clean per riportare il tavolo in uno stato in cui il cliente può usufruirne.<br><br>

<b>VECCHIE ASSUNZIONI</b> 
<ul>
<li>Nel sistema è presene un solo cliente alla volta, tutte le problematiche relative alla gestione dei task sono più limitate data la non <u>concorrenza di task</u>.</li>
<li>Task <em>clean</em> non gestito in quanto l'uscita del cliente dalla tearoom significava la terminazione dell'esecuzione del programma per elaboratore (software in termini giuridici)</li>
</ul>
<b>NUOVE ASSUNZIONI</b>
<ul>
<li>Viene simulato un cliente al tavolo 1 che svolge le azioni da specifica del problema e un secondo cliente richiede di entrare senza svolgere ulteriori azioni</li>
<li>maxstaytime non rilevante in questo contesto</li>
<li>Nessun ulteriore cliente suona alla smartbell, nessun messaggio di inform in quanto tavoli per assunzione almeno un tavolo libero.</li>
<li>Nessuna necessità di gestione di ordinazioni con identificativo del cliente.</li>
</ul>
Simuliamo l'interrombipilità dei task (clean/go home) per l'esecuzione di <a href="./ConsiderazioniIniziali.html"><b>task più prioritari</b></a> mantenendo inalterata la gestione dei task non interrompibili.<br><br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint2/SecondoSprintAnalReq">Link al modello dell'analisi dei requisiti</a>
</div>

<h2>Problem analysis</h2> 
<div class="remark">
</br>
<b>Prolematiche sorte a seguito dell'analisi dei requisiti</b>
<ul>
	<li><b>Problema 1</b>: Gestione del task clean:<br>
            In accordo con il committente è stato deciso di rendere una parte del task clean non interrompibile, a tal fine è
			stato creata un nuovo attore chiamato <i>waitercleaner</i> interno al <em>waiter</em> per gestire 3 nuovi sottotask che identificheranno lo stato di clean.
			Dunque, la gestione dei sottotask è passata alla competenza del waitercleaner, il quale riceverà un dispatch da parte del waiter per l'inizio dei sottotask e che, 
			una volta terminata l'esecuzione dell'ultimo sottotask, penserà ad informare il waiter sempre mediante dispatch del completamento del task <em>clean</em>.
			All'interruzione del task clean viene salvato un valore corrispondente al tempo di completamento che verrà in seguito riutilizzato per la sua ripresa per non avere sprechi di tempo o richieste più prioritarie
			periodiche che impediscono al task clean di terminare se ricominciasse all'inizio del task al ogni ripresa di esecuzione.<br>
			<i>es.</i> primo sottotask clean in esecuzione e costanti interruzioni dovute a richieste relativi a clienti non comporterebbe la sua terminazione.
		</li>
    <br>  
	<li><b>Problema 2</b>: Rimodellazione dello stato del tavolo:<br>
			A differenza del primo sprint è necessario rendere l'entità tavolo autonoma e non modellato come un oggetto per rendere il sistema più snello e meno vincolante.
			Di fatto il tavolo è modellato come un attore con un relativo stato il quale a sua volta avrà interazioni con il <em>waiter</em>. 

	</li><br>
</ul>
	<b> Descrizione formale delle soluzioni a seguito della descrizione delle problematiche</b><br><br>
		<u>Task clean</u>: stato relativo ad un tavolo della tearoom suddiviso in modo da avere una gestione più leggibile da un manager e per risolvere problematiche relative date dalla sua natura di task interrompibile.
		A supporto è stato creato un nuovo attore <i>waitercleaner</i> interno al <em>waiter</em>, il quale interagisce con il <i>waitermind</i> e gestisce le interruzioni e riprese di esecuzione dei sottotask introdotti.
		Questa gestione interna è stata modellata mediante messaggi di dispatch dal waitermind al waitercleaner in caso di avvio del task clean, dispatch dal <i>waitercleaner</i> al <i>waitermind</i> per indicare che il tavolo è stato pulito,
		dispatch con l'attore <i>timer</i> per sapere precisamente quanto tempo è passato e quindi quanto tempo simulare alla prossima ripresa del sottotask di clean.
		<br>METTI IL NOME DEGLI STATI INTERMEDI<br><br>
		<u>Entità timer</u>: È necessario introdurre una gestione relativa al tempo passato e rimanente di ciascuna fase dei sottotask del clean per una corretta gestione delle transizioni di stato.
			A tal fine è stata modellata una nuova entità <i>timer</i> a supporto dell'attore waitercleaner.
			Grazie a questa nuovo attore è possibile inoltre riprendere l'esecuzione al secondo esatto di interruzione del task clean a seguito di una richiesta più prioritaria 
			(vedi <a href="./../SprintIniziale/SprintIniziale.html"><b>considerazioni iniziali</b></a> per la lista di task).
		<br><br>
		<u>Entità tavolo</u>: Per ovviare al problema della rappresentazione del tavolo e della gestione del suo stato interno sono emersi <a href="./../Sprint2/Sprint2.html"><b>tre scenari</b></a>.
		Il migliore è risultato modellare l'entità tavolo come attore, <i>teatables</i>, inoltre è necessario introdurre 
		una gestione sia dell'interazione con il waiter che con gli stati dei tavoli. Gli stati dei tavoli sono memorizzati in un file di <u>knowledge base</u> scritto in Prolog (supportato dai QAK), in modo tale da ottimizzare 
		l'utilizzo dell'attore <i>teatables</i>.Da questa modellazione è possibile mandare dei dispatch da waitermind a teatables per effettuare le principali operazioni, ovvero un dispatch per occupare un determinato tavolo, 
		un dispatch per aggiornare lo stato di un tavolo a <i>cleaned</i>, un dispatch per aggiornare lo stato di un tavolo quando il cliente paga ed esce dalla tearoom.
<br><br>
Dato il rilassamento delle assunzioni rispetto agli sprint precedenti, sorte nuove situazioni:
<ul>
	<li>Situazione 1: Un cliente richiede di entrare nella tearoom vuota, ad esso viene assegnato un clientidentifier da <em>smartbell</em>.</li>
    <li>Situazione 2: Il cliente interno alla tearoom fa le richieste al waiter, il quale le esaudisce fino alla richesta del conto.</li>
    <li>Situazione 3: Un secondo cliente richiede di entrare durante la pulizia del tavolo precedentemente sporcato dal cliente iniziale, il waiter sospende l'esecuzione del task <em>clean</em> e esegue l'<em>accept</em> del cliente e il <em>convoy</em> verso il tavolo pulito.</li>
</ul>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint2/SecondoSprintAnalProb">Link al modello dell'analisi del problema</a>
<br><br>
<b>TEST PLAN</b>:</br>

Lo scopo principale di questo test plan sarà quello di verificare che il <em>clean</em> venga interrotto correttamente e che 
lo stato del tavolo rimanga aggiornato all'ultimo incontrato, mantenendo anche il tempo rimasto nel timer, così da permettere al <em>waiter</em> di riprendere 
il lavoro da dove l'ha interrotto. </br>
In questo test plan dovremo controllare che:
<ul>
    <li>Il <em>waiter</em> interrompa il task se lo stato del tavolo non ha ancora raggiunto "sanitized" </li>
    <li>il <em>waiter</em> NON interrompa il task <em>clean</em> se lo stato ha già raggiunto "sanitized" </li>
    <li>il <em>waiter</em> riprenda il task <em>clean</em> dall'ultimo stato raggiunto con il tempo rimasto in precedenza </li>
	
</ul><br>
Il test plan seguente utilizza un'entità Expected per gestire il valore atteso ed effettuare il check.
Tramite le sue variabili cleanStopped, tablePrevState e cleanRemainingTime potremo verificare se la clean è 
ferma o no, se la clean riparte dallo stato precedente all'interruzione e se il tempo rimasto è uguale
a quello registrato prima dell'interruzione.
Verrà simulato un cliente nella <em>tearoom</em> e tutto il processo che lo porta fino ad uscire; successivamente un cliente
chiederà di entrare quando il waiter fa il task clean, il quale deve essere interrotto e ripristinato dopo aver portato il nuovo cliente al tavolo.
Per verificare questo, viene utilizzato il "resource" degli attori QAK. Infatti, quando il clean viene interrotto, la risorsa deve avere
il valore atteso che si trova dentro Expected.xxx. <br>
</br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/blob/master/Sprint/Sprint2/SecondoSprintAnalProb/test/TestInterrupt.kt">TestPlan</a>
</br></br>

</div>	

<h2>Sprint review</h2> 
<div class="remark">
Problema:<br>
 Non gestione del secondo cliente.<br>
 Non gestione degli ordini/pagamenti ecc del tavolo 2. <br>
 Attori in contesti separati. <br>
</div>

<h2>Sprint retrospective</h2> 
<div class="remark">
Generalizzare la gestione dei tavoli.<br>
Attori in un unico contesto (concettuale).<br>
Rifinitura dell'entità Timer.<br>
</div>

</div>



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>