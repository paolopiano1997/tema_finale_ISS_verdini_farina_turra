<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint 2</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>. </li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	


</div>
<h2>Requirement analysis</h2>
<div class="remark">
A seguito dei risultati ottenuti nel primo sprint, continuiamo lo sviluppo 
rendendo le assunzioni sempre più vicine ai requisiti
del committente.</br>
Con riferimento alle problematiche analizzate in 
<a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>, 
proseguiamo ad analizzare il sistema considerando questa assunzione:
 <ul>
	<li>Possibilità di avere due clienti nel sistema. Consideriamo però solo una 
	determinata situazione,
    quella in cui durante la fase di clean 
    un cliente chieda di entrare nella <em>tearoom</em>. 

    <!--La seconda è quella in cui un cliente richieda di entrare nella <em>tearoom</em> mentre il <em>waiter</em>
    sta svolgendo un task non interrompibile.-->
    
    </br>
    Simuliamo una catena computazionale completa, in cui
	si parte da un cliente che richiede l'accesso, fino alla 
	sua uscita e relativa <em>clean</em> del tavolo.
    Inoltre un altro cliente richiederà l'accesso mentre il 
	<em>waiter</em> sta eseguendo il task clean.</li>
</ul>
 <ul> <li>Modellazione task clean: Prototipo del primo sprint riutilizzabile tranne per il task clean, 
 il quale dovrà gestire la nuova situazione.</li> </ul>  
</br>
Un concetto fondamentale venuto fuori durante le analisi del primo Sprint è quello dell'interrompibilità dei task. In questo caso,
simulando la situazione descritta nell'assunzione, ci avviciniamo a gestire questo aspetto nel task che potrebbe essere considerato più completo
di tutti. In effetti, il task clean è sia interrompibile che non interrompibile, infatti nell'ultima fase, quando mancano pochi secondi al termine,
il task non dovrà essere interrotto.
</br>
Nello scenario preso in considerazione potrebbe accadere che
un cliente chieda di entrare nella <em>tearoom</em> proprio nella fase finale del clean. In questo caso, è opportuno che il <em>waiter</em> comunichi
l'esito della richiesta in tempo reale, senza far aspettare troppo il cliente.
</br>
<!--I dispatch andavano scritti nel formato già simil codice, tipo: Dispatch drinkready : drinkready(V) -->
Con la necessità di dover gestire più di un cliente alla volta ora dobbiamo approfondire l'interrompibilità dei task
già analizzata nelle <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>. </br>
La situazione più complicata che dobbiamo gestire è quella dell'interruzione del task <em>clean</em>, per far entrare un cliente in sala,
e la successiva ripresa del task da dove è stato interrotto. </br>
È fondamentale quindi che il <em>waiter</em> riprenda a fare quello che stava facendo prima di aver accomodato il cliente. Nasce quindi
la necessità di trovare un modo per far "ricordare" al <em>waiter</em> quello che stava facendo.</br></br>
Il modello del primo sprint considera il task clean come un'azione composta da sottotask insensibili a messaggi sia interni
 che esterni e non interrompibili. L'assunzione effettuata in questo sprint prevede che il task Clean sia interrompibile 
quindi occorre modificare la gestione di questi sottotask in modo da renderli sensibili a interazioni. In QAK è possibile 
sfruttare la primitiva whenTime la quale ci dà la possibilità di interrompere un task simulando un 'delay' ma rimanendo sensibili a messaggi.
Questo approccio, essendo il più semplice, sarà usato nella modellazione dei sottotask relativi al clean e poi ampliato nell'analisi del problema.
</br></br>
Al fine di capire se il task clean sia stato interrotto e in relazione a quale tavolo è necessario introdurre due
 attributi nel waitermind non compresi nei requisiti del sistema iniziale, isCleanStopped (booleano che identifica se il clean è interrotto oppure no) e tableStopped (stringa che identifica il tavolo in questione). 
Per riprendere correttamente dallo stato in cui il task è stato interrotto è opportuno introdurre 3 auto-messaggi, gotoClean, gotoClean2 e gotoClean3.

Modello (riportato solo waitermind, in quanto il resto è rimasto come nel primo Sprint)<br><br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/blob/master/Sprint/Sprint2/SecondoSprintAnalReq/src/waitermind.qak">waitermind.qak</a>

</br></br>TestPlan:
<ul>
<li> Verificare la sospensione del processo Clean all'arrivo di un cliente durante la fase interrompibile del clean.</li>
</ul>
Il test plan seguente utilizza un'entità Expected per gestire il valore atteso ed effettuare il check.
Verrà simulato un cliente nella <em>tearoom</em> e tutto il processo che lo porta fino ad uscire; successivamente un cliente
chiederà di entrare quando il waiter fa il task clean, il quale deve essere interrotto e ripristinato dopo aver portato il nuovo cliente al tavolo.
Per verificare questo, viene utilizzato il "resource" degli attori QAK. Infatti, quando il clean viene interrotto, la risorsa deve avere
il valore atteso che si trova dentro Expected.expect.
</br></br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/blob/master/Sprint/Sprint2/SecondoSprintAnalReq/test/TestInterrupt.kt">TestPlan</a>
</br></br>

</div>

<h2>Problem analysis</h2> 
<div class="remark">
La prima conseguenza che porta la gestione di più di un cliente è quella di dover assegnare un tavolo ad esso.
Questo può essere fatto in modo semplice, poichè abbiamo accesso allo stato degli oggetti tavolo; basta infatti assegnare il primo tavolo
con lo stato "cleaned" nel sistema.

</br></br>
<h3> Teatables </h3> </br>
E' opportuno rifinire il concetto di "tavolo", definito nel primo Sprint.
Questo era stato modellato come un oggetto, ovvero il modo più semplice per gestirlo,
ma non necessariamente il modo migliore. Effettivamente, pensando all'entità "tavolo", potrebbe essere opportuno definirla come un attore dotato
di comportamento autonomo. Infatti, avere un'entità separata che mantenga lo stato del tavolo stesso e se lo gestisca, renderebbe il sistema 
più snello e meno vincolante. Oltretutto, in questo modo viene lasciato il puro compito da <a href="./ConsiderazioniIniziali.html#mente">"mente"</a> al waitermind e viene suddiviso a ciascun attore
un ruolo principale e fondamentale. E' quindi necessario rimodellare il tavolo con relativo stato e gestire l'interazione tra <em>waiter</em> e tavolo.
Per ovviare al problema della rappresentazione del tavolo e della gestione del suo stato interno 
sono emersi tre scenari, una modellandolo come un attore al cui waitermind invia dei dispatch per sapere il suo stato,
una in cui il tavolo informa via dispatch il waitermind ogni qual volta cambia il suo stato (dirty, occupied, clean)
ed infine una in cui il waitermind "ricorda" lo stato del tavolo a seconda delle azioni che ha compiuto precedentemente 
(es. il waiter accompagna un cliente ad un tavolo e il waiter si ricorda che quel tavolo è occupato e che non può più portare alcun cliente li).
Quest'ultima possibilità si allontana dal modello ad attori in quanto non sfrutta interazione a messaggi tra waiter e tavolo, 
riducendone la potenza espressiva e la riusabilità, pertanto è stata esclusa.
La seconda possibilità riduce la quantità di messaggi circolanti nel sistema ma inverte il controllo dello stato del tavolo, 
ovvero non è il waiter ad informarsi secondo necessità ma è il tavolo ad aggiornare il waiter ad ogni suo cambio di stato,
con la necessità della gestione dei messaggi in ingresso anche nel caso in cui il waiter stia svolgendo un'altra azione non 
legata ad accompagnare clienti o fare <em>clean</em>.
La prima possibilità è quella che sposa completamente il modello ad attori, pertanto il modello seguirà questa direzione.
Modellando l'entità tavolo come attore, in particolare l'entità gestisce entrambi i tavoli e si chiama "teatables",
 è necessario introdurre una gestione sia dell'interazione con il waiter che degli stati dei tavoli.
Gli stati dei tavoli dovranno essere memorizzati da qualche parte, in modo tale da ottimizzare l'utilizzo dell'attore "teatables".
In tal modo è possibile gestire interazioni tra waitermind e teatables per effettuare le principali interazioni. Per questo è 
 Facendo così, è possibile mandare dei dispatch da waitermind a teatables per effettuare le principali operazioni, ovvero <i>Dispatch occupy  : occupy(N)</i> per occupare un determinato tavolo,
<i>Dispatch clean   : clean(N)</i> per aggiornare lo stato di un tavolo a "cleaned", <i>Dispatch release : release(N)</i> per aggiornare lo stato di un tavolo quando il cliente se ne va.
Questa memorizzazione e gestione verrà modellata tramite fatti Prolog, poichè il modello QAK ne offre un supporto.

</br></br>

 <h3> Task <em>clean</em> </h3>
 </br>
La difficoltà di gestire sia interazioni esterne che la simulazione del clean, potrebbe indurre a modellare una nuova
entità che farà parte del <em>waiter</em> che potremo chiamare waitercleaner. Questa entità gestisce tutti gli scenari relativi 
al task clean di un tavolo; riceve un <i>Dispatch startcleaner : startcleaner(T)</i> da waitermind che identifica l'inizio del task clean,
con parametro il tavolo da pulire. Il waitercleaner a seconda dello stato del tavolo indicato saprà se deve effettivamente iniziare il clean o ripristinarlo.
Sarà presente un altro <i>Dispatch stopcleaner : stopcleaner(C)</i> che identifica il fatto di interrompersi.<br>


In questo caso è necessario utilizzare dei Dispatch in quanto non vi è necessità di ricevere una risposta.
Il waitercleaner poi si occuperà di notificare il waitermind tramite un <i>Dispatch cleanerdone : cleanerdone(C)</i> della fine del task, 
senza che esso rimanga ad aspettare la fine.

Il waitercleaner gestisce anche tutta la logica che sta al ripristino del task interrotto, in modo tale da
sollevare il waitermind da questo compito.

<br> <br>
Per la gestione degli stati intermedi del task <em>clean</em> relativi al tavolo,
una problematica è se sia opportuno far interagire teatables con waitercleaner al fine di modificare lo stato dei tavoli. 
Si chiedono al teatables gli stati e non li facciamo memorizzare al waitercleaner, ognuno fa il proprio compito.
</br></br>
<h3> Timer </h3> </br>
In accordo con il committente è stato stabilito che nell'ultima fase del clean il task non è interrompibile, ovvero negli ultimi 15 secondi dell'esecuzione del task. 
<br>È necessario dunque introdurre una gestione relativa al tempo passato e rimanente di ciascuna fase del task clean.
<br>L'ultimo stato del clean ,"sanitized", viene modellato in modo che duri 15 secondi, così da renderlo non interrompibile e semplificarne la gestione.
Per effettuare questa gestione, è opportuno modellare un'entità "timer", la quale fa da supporto al waitercleaner.
Inoltre l'introduzione di questa entità risolverà il problema di rimanere bloccati in uno stato, nel caso di ripetute interruzioni. </br></br>
Questo timer riceve un <i>Dispatch starttimer : starttimer(T)</i> con l'indicazione del tempo del
timer da innescare, in modo tale da simulare anche il tempo passato di ciascuno stato del clean. Quindi, ogni volta che interrompiamo il clean,
viene memorizzato il tempo trascorso, cosicchè quando il task verrà ripristinato, si ripartirà innescando il timer
solo con il tempo rimanente e non solo da un particolare stato, altrimenti si dovrebbe ripartire dal solito stato che precedentemente
avrebbe potuto essere quasi ultimato.
</br></br>
<!-- Un'ulteriore casistica sorge nel momento in cui il cliente che si siede al tavolo sappia già che cosa ordinare, e che quindi
faccia immediatamente l'ordine, come un cliente abituale farebbe nella realtà, senza dare tempo al <em>waiter</em> di finire di pulire il tavolo.
In questo caso, supponendo che il tavolo da pulire non abbia ancora raggiunto lo stato "sanitized", il task dovrà nuovamente essere interrotto. 
Questo scenario fa sì che il waiter interrompa più volte di fila il task <em>clean</em> nello stesso stato. Tutto questo però viene gestito 
dal fatto che utilizziamo un timer per memorizzare il tempo rimasto per ogni stato di <em>clean</em>, evitando dunque di rimanere bloccati in uno stato,
e dando la possibilità di interrompere il task <em>clean</em> tutte le volte che si vuole. -->
Di seguito è riportato il modello. waiterengine non è stato riportato, in quanto invariato.
</br></br>
 <a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/blob/master/Sprint/Sprint2/SecondoSprintAnalProb/src/waitermind.qak">waitermind.qak</a>

</br></br>
TestPlan:</br>

Lo scopo principale di questo test plan sarà quello di verificare che il <em>clean</em> venga interrotto correttamente e che 
lo stato del tavolo rimanga aggiornato all'ultimo incontrato, mantenendo anche il tempo rimasto nel timer, così da permettere al <em>waiter</em> di riprendere 
il lavoro da dove l'ha interrotto. </br>
In questo test plan dovremo controllare che:
<ul>
    <li>Il <em>waiter</em> interrompa il task se lo stato del tavolo non ha ancora raggiunto "sanitized" </li>
    <li>il <em>waiter</em> NON interrompa il task <em>clean</em> se lo stato ha già raggiunto "sanitized" </li>
    <li>il <em>waiter</em> riprenda il task <em>clean</em> dall'ultimo stato raggiunto con il tempo rimasto in precedenza </li>
	
</ul><br>
Il test plan seguente utilizza un'entità Expected per gestire il valore atteso ed effettuare il check.
Tramite le sue variabili cleanStopped, tablePrevState e cleanRemainingTime potremo verificare se la clean è 
ferma o no, se la clean riparte dallo stato precedente all'interruzione e se il tempo rimasto è uguale
a quello registrato prima dell'interruzione.
Verrà simulato un cliente nella <em>tearoom</em> e tutto il processo che lo porta fino ad uscire; successivamente un cliente
chiederà di entrare quando il waiter fa il task clean, il quale deve essere interrotto e ripristinato dopo aver portato il nuovo cliente al tavolo.
Per verificare questo, viene utilizzato il "resource" degli attori QAK. Infatti, quando il clean viene interrotto, la risorsa deve avere
il valore atteso che si trova dentro Expected.xxx. <br>
</br></br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/blob/master/Sprint/Sprint2/SecondoSprintAnalProb/test/TestInterrupt.kt">TestPlan</a>
</br></br>

</div>	

<h2>Sprint review</h2> 
<div class="remark">

</div>

<h2>Sprint retrospective</h2> 
<div class="remark">

</div>

</div>



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>