<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint 2</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>.</li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	


</div>
<h2>Requirement analysis</h2>
<div class="remark">
A seguito dei risultati ottenuti nel primo sprint, continuiamo lo sviluppo 
rendendo le assunzioni sempre più vicine ai requisiti
del committente.</br>
Con riferimento alle problematiche analizzate in 
<a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>, 
proseguiamo ad analizzare il sistema considerando questa assunzione:
 <ul>
	<li>Possibilità di avere due clienti nel sistema. Consideriamo però solo una 
	determinata situazione,
    quella in cui durante la fase di clean 
    un cliente chieda di entrare nella <em>tearoom</em>. 

    <!--La seconda è quella in cui un cliente richieda di entrare nella <em>tearoom</em> mentre il <em>waiter</em>
    sta svolgendo un task non interrompibile.-->
    
    </br>
    Simuliamo una catena computazionale completa, in cui
	si parte da un cliente che richiede l'accesso, fino alla 
	sua uscita e relativa <em>clean</em> del tavolo.
    Inoltre un altro cliente richiederà l'accesso mentre il 
	<em>waiter</em> sta eseguendo il task clean.</li>
</ul>
 <ul> <li>Modellazione task clean: Prototipo del primo sprint riutilizzabile tranne per il task clean, 
 il quale dovrà gestire la nuova situazione.</li> </ul>  
</br>
Un concetto fondamentale venuto fuori durante le analisi del primo Sprint è quello dell'interrompibilità dei task. In questo caso,
simulando la situazione descritta nell'assunzione, ci avviciniamo a gestire questo aspetto nel task che potrebbe essere considerato più completo
di tutti. In effetti, il task clean è sia interrompibile che non interrompibile, infatti nell'ultima fase, quando mancano pochi secondi al termine,
il task non dovrà essere interrotto.
</br>
Nello scenario preso in considerazione potrebbe accadere che
un cliente chieda di entrare nella <em>tearoom</em> proprio nella fase finale del clean. In questo caso, è opportuno che il <em>waiter</em> comunichi
l'esito della richiesta in tempo reale, senza far aspettare troppo il cliente.
</br>
<!--I dispatch andavano scritti nel formato già simil codice, tipo: Dispatch drinkready : drinkready(V) -->
Con la necessità di dover gestire più di un cliente alla volta ora dobbiamo approfondire l'interrompibilità dei task
già analizzata nelle <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>. </br>
La situazione più complicata che dobbiamo gestire è quella dell'interruzione del task <em>clean</em>, per far entrare un cliente in sala,
e la successiva ripresa del task da dove è stato interrotto. </br>
È fondamentale quindi che il <em>waiter</em> riprenda a fare quello che stava facendo prima di aver accomodato il cliente. Nasce quindi
la necessità di trovare un modo per far "ricordare" al <em>waiter</em> quello che stava facendo.</br></br>
Il modello del primo sprint considera il task clean come un'azione composta da sottotask insensibili a messaggi sia interni
 che esterni e non interrompibili. L'assunzione effettuata in questo sprint prevede che il task Clean sia interrompibile 
quindi occorre modificare la gestione di questi sottotask in modo da renderli sensibili a interazioni. In QAK è possibile 
sfruttare la primitiva whenTime la quale ci dà la possibilità di interrompere un task simulando un 'delay' ma rimanendo sensibili a messaggi.
Questo approccio, essendo il più semplice, sarà usato nella modellazione dei sottotask relativi al clean e poi ampliato nell'analisi del problema.
</br></br> Al fine di capire se il task clean sia stato interrotto e in relazione a quale tavolo è necessario introdurre due
 attributi nel waitermind, isCleanStopped (booleano che identifica se il clean è interrotto oppure no) e tableStopped (stringa che identifica il tavolo in questione). 
Per riprendere correttamente dallo stato in cui il task è stato interrotto è opportuno introdurre 3 auto-messaggi, gotoClean, gotoClean2 e gotoClean3.
</br></br>TestPlan:
<ul>
<li> Verificare la sospensione del processo Clean all'arrivo di un cliente durante la fase interrompibile del clean.</li>
<li> Verificare che, se arriva un cliente durante la fase non interrompibile del clean, venga comunque dato un feedback dal <em>waiter</em> <b> io lo toglierei 
dall'analisi dei requisiti, perchè il problema nasce successivamente. Qui rendiamolo facile, non preoccupandoci di sto feedback</b></li>
</ul>

</div>

<h2>Problem analysis</h2> 
<div class="remark">
La prima conseguenza che porta la gestione di più di un cliente è quella di dover assegnare un tavolo ad esso.
Questo può essere fatto in modo semplice, poichè abbiamo accesso allo stato degli oggetti tavolo; basta infatti assegnare il primo tavolo
con lo stato "cleaned" nel sistema.

</br></br>
E' opportuno rifinire il concetto di "tavolo", definito nel primo Sprint. Questo era stato modellato come un oggetto, ovvero il modo più semplice per gestirlo,
ma non necessariamente il modo migliore. Effettivamente, pensando all'entità "tavolo", potrebbe essere opportuno definirla come un attore dotato
di comportamento autonomo. Infatti, avere un'entità separata che mantenga lo stato del tavolo stesso e se lo gestisca, renderebbe il sistema 
più snello e meno vincolante. Oltretutto, in questo modo viene lasciato il puro compito da "mente" al waitermind e viene suddiviso a ciascun attore
un ruolo principale e fondamentale. E' quindi necessario rimodellare il tavolo con relativo stato e gestire l'interazione tra <em>waiter</em> e tavolo.
<b>DA PENSARE BENE COME FARE, QUALI MESSAGGI INTRODURRE E COME GESTIRE I TAVOLI.</b>
Si potrebbe mettere variabili locali in waitermind per descrivere lo stato dei tavoli
Per ovviare al problema della rappresentazione del tavolo e della gestione del suo stato interno sono emerse tre soluzioni, una modellandolo come un attore al cui waitermind invia dei messaggi per sapere il suo stato,
una in cui il tavolo informa via dispatch il waitermind ogni qual volta cambia il suo stato (dirty, occupied, clean) ed infine una in cui il waitermind "ricorda" lo stato del tavolo a seconda delle azioni che ha compiuto precedentemente 
(es. il waiter accompagna un cliente ad un tavolo e il waiter si ricorda che quel tavolo è occupato e che non può più portare alcun cliente li).
Quest'ultima possibilità si allontana dal modello ad attori in quanto non sfrutta i messaggi tra waiter e tavolo, riducendone la potenza espressiva e la riusabilità, pertanto è stata esclusa.
La seconda possibilità riduce la quantità di messaggi circolanti nel sistema ma inverte il controllo dello stato del tavolo, ovvero non è il waiter ad informarsi secondo necessità ma è il tavolo ad aggiornare il waiter ad ogni suo cambio di stato,
con la necessità della gestione dei messaggi in ingresso anche nel caso in cui il waiter sta svolgendo un'altra azione non legata ad instradamento clienti o pulizia di tavoli.
La prima possibilità è quella che sposa completamente il modello ad attori, pertanto il modello seguirà questa direzione.
Modellando l'entità tavolo come attore, è necessario introdurre una gestione sia dell'interazione con il waiter che degli stati dei tavoli.
Gli stati dei tavoli dovranno essere memorizzati da qualche parte, in modo tale da ottimizzare l'utilizzo dell'attore "teatables". Facendo così, è possibile
mandare dei dispatch da waitermind a teatables per effettuare le principali operazioni, ovvero "occupy" per occupare un determinato tavolo,
"tableclean" per aggiornare lo stato di un tavolo a "cleaned", "release" per aggiornare lo stato di un tavolo quando il cliente se ne va.
Questa memorizzazione e gestione verrà modellata tramite fatti Prolog, poichè il modello QAK ne offre un supporto.

</br></br>


<b> Per l'interazione degli stati interrompibili e degli stati interrotti è nata la problematica su chi deve gestire
 il "nome" dello stato da riesumare una volta interrotto e sulla gestione dei 'goto' per la sospensione. 
A tal fine si è ipotizzato un ulteriore <u>stato intermedio</u> che gestisce l'interazione tra processo interrompente 
e interrompibile, il quale gestisce le richieste provenienti da un processo più prioritario, inoltrando tale richiesta
 ad un processo meno prioritario. se non hai capito una sega ci lascio un disegnino nel git. </b> </br> </br>
 
La difficoltà di gestire sia interazioni esterne che la simulazione del clean, potrebbe indurre a modellare una nuova
 entità che farà parte del <em>waiter</em> che potremo chiamare waitercleaner. Questa entità gestisce tutti gli scenari relativi 
 al task clean di un tavolo; riceve un messaggio da waitermind che identifica l'inizio del task clean e un altro 
 che identifica il fatto di interrompersi. <b> Specifichiamo che tipo di messaggio e perchè </b>
Il waitercleaner gestisce anche tutta la logica che sta al ripristino del task interrotto, in modo tale da
sollevare il waitermind da questo compito.
Viene introdotto <b>(analizzare bene la differenza tra modellarlo come dispatch e req/reply)</b> un dispatch "startcleaner" 
che waitermind manda a waitercleaner con parametro il tavolo da pulire. Il waitercleaner a seconda dello stato
del tavolo indicato saprà se deve effettivamente iniziare il clean o ripristinarlo.
E' stato introdutto anche il dispatch stopcleaner tra waitermind e waitercleaner per interrompere il clean. </br> </br>
Per la gestione degli stati del tavolo, una problematica è se sia opportuno far modificare al waitercleaner i vari stati di passaggio del clean di un tavolo,
oppure se farglieli memorizzare autonomamente, senza dover modificare lo stato del tavolo globale. Questa problematica nasce dal fatto che i vari stati intermedi
non devono essere accessibili da nessuno se non da waitercleaner, quindi non sarebbe necessario effettuare questa modifica nel sistema di memorizzazione PROLOG.
Oltre a questo, dovremmo istituire un'interazione tra waitercleaner e teatables per aggiornare gli stati intermedi. Per ora questa problematica è modellata 
senza aggiornare questi stati da parte del waitercleaner.
</br></br>
Poichè è stato stabilito con il committente che nell'ultima fase del clean (quella in cui si passa da
"sanitized" a "cleaned" come stato del tavolo) in cui mancano circa 15 secondi alla fine il suddetto task non è interrompibile, 
è necessario introdurre una gestione relativa al tempo passato e rimanente di ciascuna fase del task clean.
Per effettuare questa gestione, è opportuno modellare un'entità "timer", la quale fa da supporto al waitercleaner </br></br>
Questo timer riceve un messaggio <b> vedere bene che tipo di messaggio </b> di "startTimer" con l'indicazione del tempo del
 timer da innescare, in modo tale da simulare anche il tempo passato di ciascuno stato del clean. Quindi, ogni volta che interrompiamo il clean,
viene memorizzato il tempo trascorso, cosicchè quando il task verrà ripristinato, si ripartirà innescando il timer
solo con il tempo rimanente e non solo da un particolare stato, altrimenti saremmo potuti ripartire dal solito stato che precedentemente
avrebbe potuto essere quasi finito.
</br></br>
Un ulteriore problema sorge nel momento in cui il cliente che si siede al tavolo sappia già che cosa ordinare, e che quindi
faccia immediatamente l'ordine, come un cliente abituale farebbe nella realtà, senza dare tempo al <em>waiter</em> di finire di pulire il tavolo.
In questo caso, supponendo che il tavolo da pulire non abbia ancora raggiunto lo stato "sanitized", il task dovrà nuovamente essere interrotto. 
Questo scenario fa sì che il waiter interrompa più volte di fila il task <em>clean</em> nello stesso stato.</br></br>



<b> Da rivedere e pensare bene </b>
Lo scopo principale di questo test plan sarà quello di verificare che il <em>clean</em> venga interrotto correttamente e che 
lo stato del tavolo rimanga aggiornato all'ultimo incontrato, così da permettere al <em>waiter</em> di riprendere 
il lavoro da dove l'ha interrotto. </br>
In questo test plan dovremo controllare che:
<ul>
    <li>Il <em>waiter</em> interrompa il task se lo stato del tavolo non ha ancora raggiunto "sanitized" </li>
    <li>il <em>waiter</em> NON interrompa il task <em>clean</em> se lo stato ha già raggiunto "sanitized" </li>
    <li>il <em>waiter</em> riprenda il <em>clean</em> dall'ultimo stato raggiunto una volta accompagnato il cliente al tavolo </li>
</ul>
</div>	

<h2>Sprint review</h2> 
<div class="remark">

</div>

<h2>Sprint retrospective</h2> 
<div class="remark">

</div>

</div>



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>