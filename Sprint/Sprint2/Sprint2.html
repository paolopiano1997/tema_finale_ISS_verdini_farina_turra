<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint 2</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>.</li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	


</div>
<h2>Requirement analysis</h2>
<div class="remark">
A seguito dei risultati ottenuti nel primo sprint, continuiamo lo sviluppo rendendo le assunzioni sempre più vicine ai requisiti
del committente.</br>
Con riferimento alle problematiche analizzate in <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>, 
proseguiamo ad analizzare il sistema considerando questa assunzione:
 <ul>
	<li>Possibilità di avere due clienti nel sistema. Consideriamo solo una determinata situazione,
    quella in cui durante la fase di clean 
    un cliente chieda di entrare nella <em>tearoom</em>, simulando così il task interrompibile più complesso. <b>(non parlerei qui di interrompibilità, non è un assunzione, lo spieghiamo sotto)</b> 

    <!--La seconda è quella in cui un cliente richieda di entrare nella <em>tearoom</em> mentre il <em>waiter</em>
    sta svolgendo un task non interrompibile.-->
    
    </br>
    Simuliamo una catena computazionale completa, in cui
	si parte da un cliente che richiede l'accesso, fino alla sua uscita e relativa <em>clean</em> del tavolo.
    Inoltre un altro cliente richiederà l'accesso mentre il <em>waiter</em> sta eseguendo il task clean.</li>
</ul>
 <ul> <li>Modellazione task clean: Prototipo del primo sprint riutilizzabile tranne per il task clean, il quale dovrà gestie la nuova situazione.</li> </ul>  
I dispatch presenti nello sprint precedente sono sufficienti e quindi non ne sono stati aggiunti altri.<br>
<!--I dispatch andavano scritti nel formato già simil codice, tipo: Dispatch drinkready : drinkready(V)-->
Con la necessità di dover gestire più di un cliente alla volta ora dobbiamo approfondire l'interrompibilità dei task
già analizzata nelle <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>. <br>
La situazione più complicata che dobbiamo gestire è quella dell'interruzione del task <em>clean</em>, per far entrare un cliente in sala,
e la successiva ripresa del task da dove è stato interrotto. <br>
È fondamentale quindi che il <em>waiter</em> riprenda a fare quello che stava facendo prima di aver accomodato il cliente. Nasce quindi
la necessità di implementare uno strumento per "ricordare" al <em>waiter</em> quello che stava facendo. <u>Una coda FIFO è lo strumento
più adatto.</u> <b>Attenzione a parlare qua di IMPLEMENTARE, natali triggered anche se sappiamo cosa intendevi tu, e a parlare di una SOLUZIONE più adatta. Qua non dobbiamo parlare di soluzioni, keep in mind</b><br>
<b>Il modello del primo sprint considera il task clean come un'azione composta da sottotask insensivbili a messaggi sia interni che esterni e non interrompibili. L'assunzione effettuata in questo sprint prevede che il task Clean sia interrompibile (sempre per assunzione nostra) 
quindi occorre modificare la gestione di questi sottotask in modo da renderli sensibili a interazioni.In qak è possibile sfruttare la primitiva whenTime la quale ci dà la possibilità di interrompere un task simulando un 'delay' rimanendo sensibili a messaggi.
Questo approccio essendo il più semplice sarà usato nella modellazione dei sottotask relativi al clean e poi ampliato nell'analisi del problema. </b>
<br> Al fine di capire se il task clean è stato interotto e in che tavolo è necessario introdurre due attributi del waitermind, isCleanStopped e tableStopped (isTable1). 
Per riprendere correttamente dallo stato in cui il task è stato interrotto è opportuno introdurre 3 automessaggi, gotoClean, gotoClean2 e gotoClean3.
<br> TestPlan: Verificare la sospensione del processo Clean e l'esecuzione del processo che ha fatto richiesta. 
</div>

<h2>Problem analysis</h2> 
<div class="remark">
La prima conseguenza che porta la gestione di più (2) clienti <u>contemporaneamente</u> è quella di dover assegnare un tavolo ad esso.
Questo può essere fatto semplicemente dato che abbiamo accesso allo stato degli oggetti tavolo, quindi basta assegnare il primo tavolo
con lo stato "cleaned" nel sistema. <br><br>
Come accennato nell'analisi dei requisiti è necessario implementare una coda FIFO (<b>anche qua, io analizzerei per bene la situazione: siamo sicuri che una coda FIFO sia la cosa più adatta a livello concettuale?
ricordiamoci di pensare come analisti. L'unica cosa NECESSARIA è RICORDARE e RIPRISTINARE. Mi verrebbe da pensare a una struttura più semplice di una coda FIFO. Consideriamo
che i task vengono fatti praticamente in sequenza, il waiter alla fine è uno. Questo vuol dire che se faccio un task, mi arriva una richiesta di un altro task 
e se il primo era interrompibile, <i>salvo lo stato</i>, faccio quel task e come analista mi viene da dire
che questo task LO FACCIO A ORECCHI TAPPATI, ovvero NON ascolto eventuali richieste di task in ingresso, perchè questo credo sia un concetto chiave. Se faccio un task
dopo averne interrotto uno, è essenziale essere INSENSIBILI ad altre richieste. Queste richieste saranno messe in coda DAL MODELLO QAK STESSO, quindi non importa dire COME lo farà, sappiamo che lo fa. 
Il dunque di questo discorso era sia far nasceere la problematica del "task non sensibile ad altre richieste", sia del fatto che, poichè non sarò sensibile ad altre richieste. il punto cruciale è che 
di task "attivo", "sospeso" ne avrò sempre solo uno. QUindi tanto vale avere UNA SINGOLA PORZIONE DI MEMORIA che mi metta una corrispondenza tra un EVENTUALE task "sospeso" "interrotto" e il suo stato in cui lo ho lasciato, quindi senza coda. IMHO, non deve essere LA COSA GIUSTA, ma ho appuntato la mia idea</b>), all'interno della mente del <em>waiter</em>
che gli permetta di riprendere il task interrotto precedentemente senza "dimenticarsi" o fare altri task prima di esso, ad esempio,
banalmente, tornare alla home.<br><br>
Lo stato del tavolo invece non rappresenta un problema <b>( per me invece lo rappresenta, mi fa un po' schifo modellato come un oggetto inglobato dentro il waitermind. Potremmo analizzare bene questa cosa e dedurne un'entità separata? Magari, come diceva natali, un attore che "nasconde" la vera natura del tavolo. Questo renderebbe molto più snello il modello. Pensandoci
come è fatto adesso è una modellazione VINCOLATA, cioè ho un oggetto fisso dentro il waitermind. Se lo modelliamo come attore esterno, quell'entità può essere cambiata da sola, senza toccare minimamente il waitermind, che manda solo messaggi per interagire con essa.
Potrebbe essere un altro problema da affrontare oppure diventa troppo grosso? Pensiamoci, ma così non può rimanere per me)</b> in quanto è già memorizzato nell'oggetto tavolo, accessibile dal <em>waiter</em> 
in ogni momento.<br><br>

Inoltre è stato definito con il committente <b>(so che rompo il cazzo, ma natali non ci ha ancora detto questa cosa. Glielo chiedo e spero mi dia una risposta veloce per poter modellare subito per bene sto sprint 2)</b>che quando il tavolo raggiunge lo stato di "sanitized" questo task dovrà essere completato
senza interruzioni, dato che dovrebbe terminare a breve.<br><br>
<b> Per l'interazione degli stati interrompibili e degli stati interrotti è nata la problematica su chi deve gestire il "nome" dello stato da riesumare una volta interrotto e sulla gestione dei 'goto' per la sospensione. 
A tal fine si è ipotizzato un ulteriore <u>stato intermedio</u> che gestisce l'interazione tra processo interrompente e interrompibile, il quale gestisce le richieste provenienti da un processo più prioritario, inoltrando tale richiesta ad un processo meno prioritario. se non hai capito una sega ci lascio un disegnino nel git. </b> <br> <br> 
La difficoltà di gestire sia interazioni esterne che la simulazione del clean, potrebbe indurre a modellare una nuova entità che farà parte del waiter che potremo chaimare waitercleaner. Questa entità gestisce tutti gli scenari relativi al task clean di un tavolo per esempio riceve un messaggio da waitermind che identifica l'inizio del task clean e un altro che identifica il fatto di interrompersi (stop).
Il waitercleaner gestisce anche tutta la logca dietro al ripristino del task interrotto in modo tale da sollevare il waitermind da questo compito.
Introduciamo (analizzare bene la differenza tra modellarlo come dispatch e req&repl) un dispatch startcleaner che waitermind manda a waitercleaner con parametro il tavolo da pulire. Il waitercleaner a seconda dello stato del tavolo indicato saprà se deve effettivamente iniziare il clean o ripristinarlo.
Introcuciamo anche il dispatch stopcleaner tra waitermind e waitercleaner per interrompere il clean. <br> Problema: riprendere l'esecuzione del clean da dove ci siamo fermati ( timer o progressivo), es. pulizia interrotta da accept, ripresa, interrotta da ordine, ripresa, interrotta da consegna piatti, ripresa, interr... senza un goto al prossimo stato di clean. <br> 
Un ulteriore problema sorge nel momento in cui il cliente che si siede al tavolo sappia già che cosa ordinare, e che quindi
faccia immediatamente l'ordine, come un cliente abituale farebbe nella realtà, senza dare tempo al <em>waiter</em> di finire di pulire il tavolo.
In questo caso, supponendo che il tavolo da pulire
non abbia ancora raggiunto lo stato "sanitized", il task dovrà nuovamente essere interrotto e inserito in coda.<br><br>
Nei test plan del primo sprint abbiamo già verificato che lo stato del tavolo cambi correttamente durante la fase di <em>clean</em>. <br>
Ora però nasce una nuova problematica, quando il <em>clean</em> viene interrotto ovviamente lo stato del tavolo non tornerà a quello di
<em>dirty</em> ma rimarrà salvato l'ultimo incontrato, così da permettere al <em>waiter</em> di riprendere il lavoro da dove l'ha
interrotto. <br>
Come fare questo test plan? Si potrebbe rifinire leggermente il test dello sprint precedente, parametrizzando lo stato da cui
il <em>clean</em> parte. Quindi nel caso base sempre da <em>dirty</em>, mentre nel caso di ripresa a seguito di interruzione da uno 
stato che verrà passato nei parametri.<br><br>
In questo test plan dovremo controllare che:
<ul>
    <li>Il <em>waiter</em> interrompa il task se lo stato del tavolo non ha ancora raggiunto "sanitized". </li>
    <li>il <em>waiter</em> NON interrompa il task <em>clean</em> se lo stato ha già raggiunto "sanitized"</li>
    <li>il <em>waiter</em> riprenda il <em>clean</em> dall'ultimo stato raggiunto una volta accompagnato il cliente al tavolo.</li>
</ul>
</div>	

<h2>Sprint review</h2> 
<div class="remark">

</div>

<h2>Sprint retrospective</h2> 
<div class="remark">

</div>

</div>



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>