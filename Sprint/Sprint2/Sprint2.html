<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint 2</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>. </li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	


</div>
<h2>Requirement analysis</h2>
<div class="remark">
A seguito dei risultati ottenuti nel primo sprint, continuiamo lo sviluppo 
rendendo le assunzioni sempre più vicine ai requisiti
del committente.</br>
Con riferimento alle problematiche analizzate in 
<a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>, 
proseguiamo ad analizzare il sistema considerando questa assunzione:
 <ul>
	<li>Possibilità di avere due clienti nel sistema. Consideriamo però solo una 
	determinata situazione,
    quella in cui durante la fase di clean 
    un cliente chieda di entrare nella <em>tearoom</em>. 

    <!--La seconda è quella in cui un cliente richieda di entrare nella <em>tearoom</em> mentre il <em>waiter</em>
    sta svolgendo un task non interrompibile.-->
    
    </br>
    Simuliamo una catena computazionale completa, in cui
	si parte da un cliente che richiede l'accesso, fino alla 
	sua uscita e relativa <em>clean</em> del tavolo.
    Inoltre un altro cliente richiederà l'accesso mentre il 
	<em>waiter</em> sta eseguendo il task clean.</li>
</ul>
 <ul> <li>Modellazione task clean: Prototipo del primo sprint riutilizzabile tranne per il task clean, 
 il quale dovrà gestire la nuova situazione.</li> </ul>  
</br>
Un concetto fondamentale venuto fuori durante le analisi del primo Sprint è quello dell'interrompibilità dei task. In questo caso,
simulando la situazione descritta nell'assunzione, ci avviciniamo a gestire questo aspetto nel task che potrebbe essere considerato più completo
di tutti. In effetti, il task clean è sia interrompibile che non interrompibile, infatti nell'ultima fase, quando mancano pochi secondi al termine,
il task non dovrà essere interrotto.
</br>
Nello scenario preso in considerazione potrebbe accadere che
un cliente chieda di entrare nella <em>tearoom</em> proprio nella fase finale del clean. In questo caso, è opportuno che il <em>waiter</em> comunichi
l'esito della richiesta in tempo reale, senza far aspettare troppo il cliente.
</br>
<!--I dispatch andavano scritti nel formato già simil codice, tipo: Dispatch drinkready : drinkready(V) -->
Con la necessità di dover gestire più di un cliente alla volta ora dobbiamo approfondire l'interrompibilità dei task
già analizzata nelle <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>. </br>
La situazione più complicata che dobbiamo gestire è quella dell'interruzione del task <em>clean</em>, per far entrare un cliente in sala,
e la successiva ripresa del task da dove è stato interrotto. </br>
È fondamentale quindi che il <em>waiter</em> riprenda a fare quello che stava facendo prima di aver accomodato il cliente. Nasce quindi
la necessità di trovare un modo per far "ricordare" al <em>waiter</em> quello che stava facendo.</br></br>
Il modello del primo sprint considera il task clean come un'azione composta da sottotask insensibili a messaggi sia interni
 che esterni e non interrompibili. L'assunzione effettuata in questo sprint prevede che il task Clean sia interrompibile 
quindi occorre modificare la gestione di questi sottotask in modo da renderli sensibili a interazioni. In QAK è possibile 
sfruttare la primitiva whenTime la quale ci dà la possibilità di interrompere un task simulando un 'delay' ma rimanendo sensibili a messaggi.
Questo approccio, essendo il più semplice, sarà usato nella modellazione dei sottotask relativi al clean e poi ampliato nell'analisi del problema.
</br></br>
Al fine di capire se il task clean sia stato interrotto e in relazione a quale tavolo è necessario introdurre due
 attributi nel waitermind non compresi nei requisiti del sistema iniziale, isCleanStopped (booleano che identifica se il clean è interrotto oppure no) e tableStopped (stringa che identifica il tavolo in questione). 
Per riprendere correttamente dallo stato in cui il task è stato interrotto è opportuno introdurre 3 auto-messaggi, gotoClean, gotoClean2 e gotoClean3.

Modello (riportato solo waitermind, in quanto il resto è rimasto come nel primo Sprint)
<pre>
System tearoom

//Movements messages
Request moveto : moveto(X,Y)
Reply done : done(X,Y)

//Init messages
Request start : start(S)
Reply ready : ready(V)

//Client and tearoom messages
Request enter : enter(ID)
Reply accept : accept(C)
Dispatch drinkready : drinkready(V)
Dispatch clientready : clientready(C)
Dispatch paymentready : paymentready(P)
Dispatch order : order(O)
Dispatch end : end (E)

Dispatch gotoclean : gotoclean(G)
Dispatch gotoclean2 : gotoclean2(G)
Dispatch gotoclean3 : gotoclean3(G)


Context ctxbasicrobot     ip [host="localhost"   port=8020] 
Context ctxtearoom ip [ host="127.0.0.1" port=8068 ]

ExternalQActor basicrobot  context ctxbasicrobot

CodedQActor waiterengine context ctxtearoom className "it.unibo.waiterengine.Waiterengine"

QActor waitermind context ctxtearoom{
[#
//	//Coordinates of the entrance door
	val X_Entrancedoor = "0"
	val Y_Entrancedoor = "4"

//	//Coordinates of the exit door
	val X_Exitdoor = "6"
	val Y_Exitdoor = "4"
	
//  //Coordinates of the barman
	val X_servicedesk = "6"
	val Y_servicedesk = "0"	

//	//Coordinates Tables
	val X_teatable1     = "2"
	val Y_teatable1     = "2"

	val X_teatable2     = "4"
	val Y_teatable2     = "2"

	//Coordinates of the home
    val X_home			= "0"
	val Y_home 			= "0"

	val	Cleantime = 3000L
	val Servicetime = 5000L
	val CollectTime = 4000L
	data class Table(var state: String ="cleaned") {
		
	}
	val table1 = Table()
	val table2 = Table()
	var stateTable1 = "cleaned"
	var stateTable2 = "cleaned"
	
	var isCleanStopped = false
	var tableStopped = ""
#]
	State s0 initial {
		discardMsg Off
		println("waitermind   |||   init")
		request waiterengine -m start : start(id)
	}
	Transition t0 whenReply ready -> home
	
	State reachhome{
		println("waitermind   |||   reachhome")
		request waiterengine -m moveto : moveto($X_home,$Y_home)
	}
	Transition t0 whenReply done -> home
	
	State home{
		println("waitermind   |||   home")
		updateResource [# "home" #]
	}
	Transition t0 whenRequest enter -> accept
				  whenMsg clientready -> take
				  whenMsg drinkready -> reachBarman
				  whenMsg paymentready -> reachTableCollect
				  whenMsg end -> endwork
	
	State accept {
		println("waitermind   |||   accept")
		replyTo enter with accept : accept(idclient)
	}
	Goto reachEntranceDoor
	
	State reachEntranceDoor {
		println("waitermind   |||   reachEntranceDoor")
		//updateResource[# "reachEntranceDoor" #]
		request waiterengine -m moveto : moveto($X_Entrancedoor, $Y_Entrancedoor)
	}
	Transition t0 whenReply done -> checkTables
	
	State checkTables{
		println("waitermind   |||   checkTables")	
	}
	Goto convoyToTable1 if [# table1.state=="cleaned" #] else convoyToTable2
	//Cruciale questo if/else, per capire in quale tavolo andare
	
	State convoyToTable1{
		println("waitermind   |||   convoyToTable1")
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
		[# table1.state= "occupied" #]
		println("waitermind   |||   table1 state occupied")
		//updateResource [# "convoyToTable1" #]
		delay 5000
	}
	Transition t0 whenReply done -> checkCleanHome
	
	State convoyToTable2{
		println("waitermind   |||   convoyToTable2")
		request waiterengine -m moveto : moveto ($X_teatable2,$Y_teatable2)
		[# table2.state= "occupied" #]
		println("waitermind   |||   table2 state occupied")
		//updateResource [# "convoyToTable2" #]
		delay 5000
	}
	Transition t0 whenReply done -> checkCleanHome
	
	State checkCleanHome{
		println("waitermind   |||   checkClean")
	}
	Goto reachhome if [# !isCleanStopped #] else reachTable1CleanStopped
	
	State reachTable1CleanStopped{
		println("waitermind   |||   reachTable1CleanStopped")
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> checkCleanStopped
	
	State checkCleanStopped {
		println("waitermind   |||   checkCleanStopped")
		if [# tableStopped=="table1" #] {
			if [# table1.state == "dirty" #]{
				forward waitermind -m gotoclean : gotoclean(clean1)
			}
			else{
				if[# table1.state == "undirty" #]{
					forward waitermind -m gotoclean2 : gotoclean2(clean2)
				}
				else {
					forward waitermind -m gotoclean3 : gotoclean3(clean3)
				}
			}
			
		}
		else{
			if [# table2.state == "dirty" #]{
				forward waitermind -m gotoclean : gotoclean(clean1)
			}
			else{
				if[# table2.state == "undirty" #]{
					forward waitermind -m gotoclean2 : gotoclean2(clean2)
				}
				else{
					forward waitermind -m gotoclean3 : gotoclean3(clean3)
				}
			}
		}
	}
	Transition t0 whenMsg gotoclean -> clean
					whenMsg gotoclean2 -> clean2
					whenMsg gotoclean3 -> clean3
	
	State take{
		println("waitermind   |||   take")
		updateResource [# "take" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> transmit
	
	State transmit{
		println("waitermind   |||   transmit")
		updateResource [# "transmit" #]
		//forward barman -m order : order(payloadArg(0))
	}
	Goto reachhome
	
	State reachBarman{
		println("waitermind   |||   reachBarman")
		updateResource[# "reachBarman" #]
		request waiterengine -m moveto: moveto($X_servicedesk,$Y_servicedesk)
	}
	Transition t0 whenReply done -> serve
	
	State serve{
		println("waitermind   |||   serve")
		updateResource[# "serve" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> reachhome
	
	State reachTableCollect {
		println("waitermind   |||   reachTable")
		updateResource[# "reachTable" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> collect
	
	State reachTableClean {
		println("waitermind   |||   reachTable")
		updateResource[# "reachTable" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> clean
	
	State collect {
		println("waitermind   |||   collect")
		updateResource[# "collect" #]
		delayVar CollectTime
	}
	Goto convoyToExitDoor
	
	State convoyToExitDoor{
		println("waitermind   |||   convoyToExitDoor")
		updateResource[# "convoyToExitDoor" #]
		request waiterengine -m moveto : moveto($X_Exitdoor,$Y_Exitdoor)
		[# table1.state = "dirty" #]
		println("waitermind   |||   table state dirty")
		delay 5000
	}
	Transition t0 whenReply done -> reachTableClean
	
	State stopCleanEnter {
		updateResource[# "cleanStopped" #]
		[# 
			isCleanStopped = true
			tableStopped = "table1"	
		#]
	}
	Goto accept
	
	
	State clean{
		println("waitermind   |||   clean")
		
		//updateResource[# "undirty" #]
		//delayVar Cleantime
		//[# table1.state = "undirty" #]
		//println("waitermind   |||   clean")
	}
	Transition t0 whenTimeVar Cleantime -> clean2
					whenRequest enter -> stopCleanEnter
	
	State clean2{
		println("waitermind   |||   clean2")
		[# table1.state = "undirty" #]
		//updateResource[# "sanitized" #]
		//delayVar Cleantime
		//println("waitermind   |||   table state sanitized")
	}
	Transition t0 whenTimeVar Cleantime -> clean3
					whenRequest enter -> stopCleanEnter
	
	State clean3{
		println("waitermind   |||   clean3")
		//updateResource[# "cleaned" #]
		//delayVar Cleantime
		[# table1.state = "sanitized" #]
		//println("waitermind   |||   table state cleaned")
	}
	Transition t0 whenTimeVar Cleantime -> clean4
					whenRequest enter -> stopCleanEnter

	State clean4{
		[# table1.state = "cleaned" #]
	}
	Goto reachhome
	
	State endwork{
		println("waitermind   |||   end")
		terminate 0
	}
}

</pre>

</br></br>TestPlan:
<ul>
<li> Verificare la sospensione del processo Clean all'arrivo di un cliente durante la fase interrompibile del clean.</li>
</ul>
Il test plan seguente utilizza un'entità Expected per gestire il valore atteso ed effettuare il check.
Verrà simulato un cliente nella <em>tearoom</em> e tutto il processo che lo porta fino ad uscire; successivamente un cliente
chiederà di entrare quando il waiter fa il task clean, il quale deve essere interrotto e ripristinato dopo aver portato il nuovo cliente al tavolo.
Per verificare questo, viene utilizzato il "resource" degli attori QAK. Infatti, quando il clean viene interrotto, la risorsa deve avere
il valore atteso che si trova dentro Expected.expect.
</br>
<pre>
class TestWaiterTableStates {
	var waitermind            : ActorBasic? = null
	//val mqttTest   	      = MqttUtils("test") 
	val initDelayTime     = 1000L

	val enter = MsgUtil.buildRequest("waitermind","enter","enter","waitermind")
	val clientready = MsgUtil.buildDispatch("waitermind","clientready","clientready","waitermind")	
	val drinkready = MsgUtil.buildDispatch("waitermind","drinkready","drinkready","waitermind")
	val paymentready = MsgUtil.buildDispatch("waitermind","paymentready","paymentready","waitermind")
	
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Before
	fun systemSetUp() {
   		kotlin.concurrent.thread(start = true) {
			it.unibo.ctxtearoom.main()
		}
	}

	@After
	fun terminate() {
		println("%%%  TestWaiter terminate ")
	}
	
	fun checkState(){
		if(waitermind!=null)
			assert(waitermind!!.geResourceRep()==Expected.expect)
	}
	
	@Test
	fun testRobotboundary(){
	 	runBlocking{
 			while( waitermind == null ){
				println("testWaiterPosition waits for waitermind ... ")
				delay(initDelayTime)  //time for robot to start
				waitermind = it.unibo.kactor.sysUtil.getActor("waitermind")
 			}
			
			MsgUtil.sendMsg(enter,waitermind!!)
 			delay(20000)
			MsgUtil.sendMsg(clientready,waitermind!!)
			delay(20000)
			MsgUtil.sendMsg(drinkready,waitermind!!)
			delay(20000)
			MsgUtil.sendMsg(paymentready,waitermind!!)
			delay(15000)
			MsgUtil.sendMsg(enter,waitermind!!)
			delay(6000)
			checkState()
 			delay(20000)
			MsgUtil.sendMsg("end","end","end",waitermind!!)
 			if( waitermind != null ) waitermind!!.waitTermination()
  		}
	 	println("testWaiterPosition BYE  ")  
	}
}
</pre>

</div>

<h2>Problem analysis</h2> 
<div class="remark">
La prima conseguenza che porta la gestione di più di un cliente è quella di dover assegnare un tavolo ad esso.
Questo può essere fatto in modo semplice, poichè abbiamo accesso allo stato degli oggetti tavolo; basta infatti assegnare il primo tavolo
con lo stato "cleaned" nel sistema.

</br></br>
<h3> Teatables </h3> </br>
E' opportuno rifinire il concetto di "tavolo", definito nel primo Sprint.
Questo era stato modellato come un oggetto, ovvero il modo più semplice per gestirlo,
ma non necessariamente il modo migliore. Effettivamente, pensando all'entità "tavolo", potrebbe essere opportuno definirla come un attore dotato
di comportamento autonomo. Infatti, avere un'entità separata che mantenga lo stato del tavolo stesso e se lo gestisca, renderebbe il sistema 
più snello e meno vincolante. Oltretutto, in questo modo viene lasciato il puro compito da <a href="./ConsiderazioniIniziali.html#mente">"mente"</a> al waitermind e viene suddiviso a ciascun attore
un ruolo principale e fondamentale. E' quindi necessario rimodellare il tavolo con relativo stato e gestire l'interazione tra <em>waiter</em> e tavolo.
Per ovviare al problema della rappresentazione del tavolo e della gestione del suo stato interno 
sono emersi tre scenari, una modellandolo come un attore al cui waitermind invia dei dispatch per sapere il suo stato,
una in cui il tavolo informa via dispatch il waitermind ogni qual volta cambia il suo stato (dirty, occupied, clean)
ed infine una in cui il waitermind "ricorda" lo stato del tavolo a seconda delle azioni che ha compiuto precedentemente 
(es. il waiter accompagna un cliente ad un tavolo e il waiter si ricorda che quel tavolo è occupato e che non può più portare alcun cliente li).
Quest'ultima possibilità si allontana dal modello ad attori in quanto non sfrutta interazione a messaggi tra waiter e tavolo, 
riducendone la potenza espressiva e la riusabilità, pertanto è stata esclusa.
La seconda possibilità riduce la quantità di messaggi circolanti nel sistema ma inverte il controllo dello stato del tavolo, 
ovvero non è il waiter ad informarsi secondo necessità ma è il tavolo ad aggiornare il waiter ad ogni suo cambio di stato,
con la necessità della gestione dei messaggi in ingresso anche nel caso in cui il waiter stia svolgendo un'altra azione non 
legata ad accompagnare clienti o fare <em>clean</em>.
La prima possibilità è quella che sposa completamente il modello ad attori, pertanto il modello seguirà questa direzione.
Modellando l'entità tavolo come attore, in particolare l'entità gestisce entrambi i tavoli e si chiama "teatables",
 è necessario introdurre una gestione sia dell'interazione con il waiter che degli stati dei tavoli.
Gli stati dei tavoli dovranno essere memorizzati da qualche parte, in modo tale da ottimizzare l'utilizzo dell'attore "teatables".
In tal modo è possibile gestire interazioni tra waitermind e teatables per effettuare le principali interazioni. Per questo è 
 Facendo così, è possibile mandare dei dispatch da waitermind a teatables per effettuare le principali operazioni, ovvero <i>Dispatch occupy  : occupy(N)</i> per occupare un determinato tavolo,
<i>Dispatch clean   : clean(N)</i> per aggiornare lo stato di un tavolo a "cleaned", <i>Dispatch release : release(N)</i> per aggiornare lo stato di un tavolo quando il cliente se ne va.
Questa memorizzazione e gestione verrà modellata tramite fatti Prolog, poichè il modello QAK ne offre un supporto.

</br></br>

 <h3> Task <em>clean</em> </h3>
 </br>
La difficoltà di gestire sia interazioni esterne che la simulazione del clean, potrebbe indurre a modellare una nuova
entità che farà parte del <em>waiter</em> che potremo chiamare waitercleaner. Questa entità gestisce tutti gli scenari relativi 
al task clean di un tavolo; riceve un <i>Dispatch startcleaner : startcleaner(T)</i> da waitermind che identifica l'inizio del task clean,
con parametro il tavolo da pulire. Il waitercleaner a seconda dello stato del tavolo indicato saprà se deve effettivamente iniziare il clean o ripristinarlo.
Sarà presente un altro <i>Dispatch stopcleaner : stopcleaner(C)</i> che identifica il fatto di interrompersi.<br>


In questo caso è necessario utilizzare dei Dispatch in quanto non vi è necessità di ricevere una risposta.
Il waitercleaner poi si occuperà di notificare il waitermind tramite un <i>Dispatch cleanerdone : cleanerdone(C)</i> della fine del task, 
senza che esso rimanga ad aspettare la fine.

Il waitercleaner gestisce anche tutta la logica che sta al ripristino del task interrotto, in modo tale da
sollevare il waitermind da questo compito.

<br> <br>
Per la gestione degli stati intermedi del task <em>clean</em> relativi al tavolo,
una problematica è se sia opportuno far interagire teatables con waitercleaner al fine di modificare lo stato dei tavoli. 
Si chiedono al teatables gli stati e non li facciamo memorizzare al waitercleaner, ognuno fa il proprio compito.
</br></br>
<h3> Timer </h3> </br>
In accordo con il committente è stato stabilito che nell'ultima fase del clean il task non è interrompibile, ovvero negli ultimi 15 secondi dell'esecuzione del task. 
<br>È necessario dunque introdurre una gestione relativa al tempo passato e rimanente di ciascuna fase del task clean.
<br>L'ultimo stato del clean ,"sanitized", viene modellato in modo che duri 15 secondi, così da renderlo non interrompibile e semplificarne la gestione.
Per effettuare questa gestione, è opportuno modellare un'entità "timer", la quale fa da supporto al waitercleaner.
Inoltre l'introduzione di questa entità risolverà il problema di rimanere bloccati in uno stato, nel caso di ripetute interruzioni. </br></br>
Questo timer riceve un <i>Dispatch starttimer : starttimer(T)</i> con l'indicazione del tempo del
timer da innescare, in modo tale da simulare anche il tempo passato di ciascuno stato del clean. Quindi, ogni volta che interrompiamo il clean,
viene memorizzato il tempo trascorso, cosicchè quando il task verrà ripristinato, si ripartirà innescando il timer
solo con il tempo rimanente e non solo da un particolare stato, altrimenti si dovrebbe ripartire dal solito stato che precedentemente
avrebbe potuto essere quasi ultimato.
</br></br>
<!-- Un'ulteriore casistica sorge nel momento in cui il cliente che si siede al tavolo sappia già che cosa ordinare, e che quindi
faccia immediatamente l'ordine, come un cliente abituale farebbe nella realtà, senza dare tempo al <em>waiter</em> di finire di pulire il tavolo.
In questo caso, supponendo che il tavolo da pulire non abbia ancora raggiunto lo stato "sanitized", il task dovrà nuovamente essere interrotto. 
Questo scenario fa sì che il waiter interrompa più volte di fila il task <em>clean</em> nello stesso stato. Tutto questo però viene gestito 
dal fatto che utilizziamo un timer per memorizzare il tempo rimasto per ogni stato di <em>clean</em>, evitando dunque di rimanere bloccati in uno stato,
e dando la possibilità di interrompere il task <em>clean</em> tutte le volte che si vuole. -->
Di seguito è riportato il modello. waiterengine non è stato riportato, in quanto invariato.
</br></br>
<b>waitermind.qak</b></br>
<pre>
System tearoom

//Movements messages
Request moveto : moveto(X,Y)
Reply done : done(X,Y)

//Init messages
Request start : start(S)
Reply ready : ready(V)

//Client and tearoom messages
Request enter : enter(ID)
Reply accept : accept(C)
Dispatch drinkready : drinkready(V)
Dispatch clientready : clientready(C)
Dispatch paymentready : paymentready(P)
Dispatch order : order(O)
Dispatch end : end (E)


Dispatch startcleaner : startcleaner(T)
Dispatch cleanerdone : cleanerdone(C)
Dispatch stopcleaner : stopcleaner(C)

Dispatch occupy  : occupy(N)
Dispatch release : release(N)
Dispatch clean   : clean(N)

Request isClean : isClean(N)
Reply isCleanDone : isCleanDone(N,E)

Request isTableStopped : isTableStopped(T)
Reply isTableStoppedDone : isTableStoppedDone(E)

Dispatch gotohome : gotohome(G)

Dispatch gotoclean : gotoclean(G)
Dispatch gotoclean2 : gotoclean2(G)
Dispatch gotoclean3 : gotoclean3(G)

Dispatch gototable1 : gototable1(T)
Dispatch gototable2 : gototable2(T)


Context ctxbasicrobot     ip [host="localhost"   port=8020]
Context ctxtearoom ip [ host="::1" port=8068 ]
Context ctxtearoom_dummy   ip [host="127.0.0.1" port=8050] 
Context ctxtearoom_teatables ip [host="192.168.0.38" port=8045]    

CodedQActor teatables context ctxtearoom_teatables className "it.unibo.teatables.Teatables"
CodedQActor waitercleaner context ctxtearoom_dummy className "it.unibo.waitercleaner.Waitercleaner"
CodedQActor waiterengine context ctxtearoom className "it.unibo.waiterengine.Waiterengine"

ExternalQActor basicrobot  context ctxbasicrobot

QActor waitermind context ctxtearoom{
[#
//	//Coordinates of the entrance door
	val X_Entrancedoor = "0"
	val Y_Entrancedoor = "4"

//	//Coordinates of the exit door
	val X_Exitdoor = "6"
	val Y_Exitdoor = "4"
	
//  //Coordinates of the barman
	val X_servicedesk = "6"
	val Y_servicedesk = "0"	

//	//Coordinates Tables
	val X_teatable1     = "2"
	val Y_teatable1     = "2"

	val X_teatable2     = "4"
	val Y_teatable2     = "2"

	//Coordinates of the home
    val X_home			= "0"
	val Y_home 			= "0"

	val Servicetime = 5000L
	val CollectTime = 4000L
	
#]
	State s0 initial {
		discardMsg Off
		println("waitermind   |||   init")
		request waiterengine -m start : start(id)
	}
	Transition t0 whenReply ready -> home
	
	State reachhome{
		println("waitermind   |||   reachhome")
		request waiterengine -m moveto : moveto($X_home,$Y_home)
	}
	Transition t0 whenReply done -> home
	
	State home{
		println("waitermind   |||   home")
		updateResource [# "home" #]
	}
	Transition t0 whenRequest enter -> accept
				  whenMsg clientready -> take
				  whenMsg drinkready -> reachBarman
				  whenMsg paymentready -> reachTableCollect
				  whenMsg end -> endwork
	
	State accept {
		println("waitermind   |||   accept")
		replyTo enter with accept : accept(idclient)
	}
	Goto reachEntranceDoor
	
	State reachEntranceDoor {
		println("waitermind   |||   reachEntranceDoor")
		//updateResource[# "reachEntranceDoor" #]
		request waiterengine -m moveto : moveto($X_Entrancedoor, $Y_Entrancedoor)
	}
	Transition t0 whenReply done -> checkTables
	
	State checkTables{
		println("waitermind   |||   checkTables")
		request teatables -m isClean : isClean(1)
	}
	Transition t0 whenReply isCleanDone -> checkIsCleanDone1
	
	State checkIsCleanDone1{
		onMsg(isCleanDone : isCleanDone(N,E)){
			if [# payloadArg(1)=="yes" #]{
				forward waitermind -m gototable1 : gototable1(table1)
			}
			else{
				request teatables -m isClean : isClean(2)
			}
		}
	}
	Transition t0 whenMsg gototable1 -> convoyToTable1
				whenReply isCleanDone -> checkIsCleanDone2
	
	State checkIsCleanDone2{
		onMsg(isCleanDone : isCleanDone(N,E)){
			if [# payloadArg(1)=="yes" #]{
				forward waitermind -m gototable2 : gototable2(table2)
			}
		}
	}
	Goto convoyToTable2
	
	State convoyToTable1{
		println("waitermind   |||   convoyToTable1")
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
//		[# table1.state= "occupied" #]
		forward teatables -m occupy : occupy(1)
		println("waitermind   |||   table1 state occupied")
		//updateResource [# "convoyToTable1" #]
		delay 5000
	}
	Transition t0 whenReply done -> checkCleanHome
	
	State convoyToTable2{
		println("waitermind   |||   convoyToTable2")
		request waiterengine -m moveto : moveto ($X_teatable2,$Y_teatable2)
		//[# table2.state= "occupied" #]
		forward teatables -m occupy : occupy(2)
		println("waitermind   |||   table2 state occupied")
		//updateResource [# "convoyToTable2" #]
		delay 5000
	}
	Transition t0 whenReply done -> checkCleanHome
	
	State checkCleanHome{
		println("waitermind   |||   checkClean")
		request waitercleaner -m isTableStopped : isTableStopped(isStopped)
	}
	Transition t0 whenReply isTableStoppedDone -> checkIsTableStopped
	

	State checkIsTableStopped{
		println("waitermind   |||   checkIsTableStopped")
		onMsg( isTableStoppedDone : isTableStoppedDone(E)){
			if [# payloadArg(0)=="0" #]{ //0 non è interrotto nessun clean
				forward waitermind -m gotohome : gotohome(go)
			}
			else{
				if[# payloadArg(0)=="1" #]{ //Interrotto clean table1
					forward waitermind -m gototable1 : gototable1(go)
				}
				else{
					//forward waitermind -m gototable2 : gototable2(go)
				}
			}
		}
	}
	Transition t0 whenMsg gotohome -> reachhome
				whenMsg gototable1 -> reachTable1CleanStopped
				//whenMsg gototable2 -> reachTable2CleanStopped per ora il modello associa al primo cliente sempre il table1, quindi non si verifica
	
	State reachTable1CleanStopped{
		println("waitermind   |||   reachTable1CleanStopped")
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> cleanTable1
	
	State take{
		println("waitermind   |||   take")
		updateResource [# "take" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> transmit
	
	State transmit{
		println("waitermind   |||   transmit")
		updateResource [# "transmit" #]
		//forward barman -m order : order(payloadArg(0))
	}
	Goto reachhome
	
	State reachBarman{
		println("waitermind   |||   reachBarman")
		updateResource[# "reachBarman" #]
		request waiterengine -m moveto: moveto($X_servicedesk,$Y_servicedesk)
	}
	Transition t0 whenReply done -> serve
	
	State serve{
		println("waitermind   |||   serve")
		updateResource[# "serve" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> reachhome
	
	State reachTableCollect {
		println("waitermind   |||   reachTable")
		updateResource[# "reachTable" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> collect
	
	State reachTableClean {
		println("waitermind   |||   reachTable")
		updateResource[# "reachTable" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> cleanTable1
	
	State collect {
		println("waitermind   |||   collect")
		updateResource[# "collect" #]
		delayVar CollectTime
	}
	Goto convoyToExitDoor
	
	State convoyToExitDoor{
		println("waitermind   |||   convoyToExitDoor")
		updateResource[# "convoyToExitDoor" #]
		request waiterengine -m moveto : moveto($X_Exitdoor,$Y_Exitdoor)
		forward teatables -m release : release(1)
		delay 5000
	}
	Transition t0 whenReply done -> reachTableClean
	
	State cleanTable1{
		println("waitermind   |||   cleanTable1")
		forward waitercleaner -m startcleaner : startcleaner(1)
	}
	Transition t0 whenMsg cleanerdone -> reachhome //Qua non posso ricevere altri messaggi per l'assunzione fatta
				whenRequest enter -> handleEnter
	
	State cleanTable2{
		println("waitermind   |||   cleanTable2")
		forward waitercleaner -m startcleaner : startcleaner(2)
	}
	Transition t0 whenMsg cleanerdone -> reachhome
	
	State handleEnter {
		forward waitercleaner -m stopcleaner : stopcleaner(stop)
	}
	Goto accept
	
	State endwork{
		println("waitermind   |||   end")
		terminate 0
	}
}
</pre>

</br></br>
<b>waitercleaner.qak</b></br></br>
<pre>
System subtearoom

Dispatch startcleaner : startcleaner(T)
Dispatch cleanerdone : cleanerdone(C)
Dispatch stopcleaner : stopcleaner(C)

Dispatch starttimer : starttimer(T)
Dispatch endtime : endtime(T)

Dispatch setTableState : setTableState(N,S)

Request tableState : tableState(N)
Reply state : state(N,S)

Request stoptimer : stoptimer(T)
Reply okStop : okStop(T)

Dispatch gotodirty : gotodirty(G)
Dispatch gotoundirty : gotoundirty(G)
Dispatch gotosanitized : gotosanitized(G)


Request isTableStopped : isTableStopped(T)
Reply isTableStoppedDone : isTableStoppedDone(E)

Context ctxtearoom ip [ host="localhost" port=8068 ]
Context ctxtearoom_dummy   ip [host="127.0.0.1" port=8050] 
Context ctxtearoom_teatables ip [host="192.168.0.38" port=8045]    

CodedQActor teatables context ctxtearoom_teatables className "it.unibo.teatables.Teatables"
CodedQActor timer context ctxtearoom_teatables className "it.unibo.timer.Timer"
CodedQActor waitermind context ctxtearoom className "it.unibo.waitermind.Waitermind"

QActor waitercleaner context ctxtearoom_dummy {


	[#
		var Table = ""
		val	Cleantime = 3000L
		var Clean = Cleantime
		
	#]
	State s0 initial{// Accettazione richieste/dispatch
		println("waitercleaner   |||   init")
	}
	Goto wait
	
	State wait {
		onMsg(isTableStopped : isTableStopped(T)){
			replyTo isTableStopped with isTableStoppedDone : isTableStoppedDone(0)
		}
		else{
			println("waitercleaner   |||   wait")
		}
	}
	Transition t0 whenMsg startcleaner		 -> preDirty
				  whenRequest isTableStopped -> wait
	
	State timerStop{
		request timer -m stoptimer : stoptimer(stop)
	}
	Transition t0 whenReply okStop -> stop
	
	State stop {
		updateResource[# "cleanStopped" #]
		onMsg(okStop : okStop(T)){
			[# Clean = Cleantime - payloadArg(0).toLong() #]
		}
	}
	Transition t0 whenMsg startcleaner -> preStart
				whenRequest isTableStopped -> replyTableStop
				
	State replyTableStop{
		replyTo isTableStopped with isTableStoppedDone : isTableStoppedDone($Table)
	}
	Goto stop
	
	State preStart{
		updateResource[# "nonStopped" #]
		onMsg(startcleaner : startcleaner(T)){
			request teatables -m tableState : tableState(payloadArg(0))
		}
	}
	Transition t0 whenReply state -> checkState
	
	State checkState {
		onMsg(state : state(N,S)){
			if[# payloadArg(0) == "dirty" #]{
				forward waitercleaner -m gotodirty : gotodirty(go)
			}
			else{
				if[# payloadArg(0)=="undirty" #]
				{
					forward waitercleaner -m gotoundirty : gotoundirty(go)
				}
				else{
					forward waitercleaner -m gotosanitized : gotosanitized(go)
				}
			}
		}
	}
	Transition t0 whenMsg gotodirty -> cleanDirty
					whenMsg gotoundirty -> cleanUndirty
					whenMsg gotosanitized -> cleanSanitized
					
	State preDirty{
		[# Clean = Cleantime #]
		onMsg(startcleaner : startcleaner(T)){
			[# Table = payloadArg(0) #]
		}
	}
	Goto cleanDirty
	
	State preUndirty{
		[# Clean = Cleantime #]
	}
	Goto cleanUndirty
	
	State preSanitized{
		[# Clean = Cleantime #]
	}
	Goto cleanSanitized
	
	State cleanDirty { //Inizio catena di clean
		onMsg(isTableStopped : isTableStopped(T)){
			replyTo isTableStopped with isTableStoppedDone : isTableStoppedDone(0)
		}
		else {
			forward timer -m starttimer : starttimer($Clean)
		}
	}
	Transition t0 whenMsg endtime -> preUndirty
				whenMsg stopcleaner -> timerStop
				whenRequest isTableStopped -> cleanDirty
				
	
	State cleanUndirty{
		onMsg(isTableStopped : isTableStopped(T)){
			replyTo isTableStopped with isTableStoppedDone : isTableStoppedDone(0)
		}
		else{
			forward teatables -m setTableState : setTableState($Table,undirty)
			forward timer -m starttimer : starttimer($Clean)
		}
		
	}
	Transition t0 whenMsg endtime -> preSanitized
				whenMsg stopcleaner -> timerStop
				whenRequest isTableStopped -> cleanUndirty
	
	State cleanSanitized{
		onMsg(isTableStopped : isTableStopped(T)){
			replyTo isTableStopped with isTableStoppedDone : isTableStoppedDone(0)
		}
		else{
			forward teatables -m setTableState : setTableState($Table,sanitized)
			forward timer -m starttimer : starttimer($Clean)
		}
		
	}
	Transition t0 whenMsg endtime -> cleanDone
				whenMsg stopcleaner -> timerStop
				whenRequest isTableStopped -> cleanSanitized
	
	State cleanDone{ //Messaggio al waitermind di "fine"
		forward teatables -m setTableState : setTableState($Table,cleaned)
		forward waitermind -m cleanerdone : cleanerdone(done)
	}
	Goto wait
	
}
</pre>

</br></br>

<b>timer.qak</b></br></br>

<pre>
System subtearoom

Dispatch starttimer : starttimer(T)
Dispatch endtime : endtime(T)

Request stoptimer : stoptimer(T)
Reply okStop : okStop(T)

Context ctxtearoom_teatables ip [host="192.168.0.38" port=8045] 
Context ctxtearoom_dummy   ip [host="127.0.0.1" port=8050] 

CodedQActor waitercleaner context ctxtearoom_dummy className "it.unibo.waitercleaner.Waitercleaner" 

QActor timer context ctxtearoom_teatables {


	[# 
		var Time: Long = 0
		var StartTime : Long = 0	
		var Duration : Long	= 0
	#]
	State s0 initial {
		println("timer   |||   init")
	}
	Goto wait
	
	State wait {
		println("timer   |||   wait")
	}
	Transition t0 whenMsg starttimer -> start
	
	State start{
		onMsg(starttimer : starttimer(T)) {
			[# Time = payloadArg(0).toLong() #]
			memoCurrentTime StartTime
		}
	}
	Transition t0 whenTimeVar Time -> timeFinish
				whenRequest stoptimer -> stop
				
	State stop{
		setDuration Duration from StartTime
		replyTo stoptimer with okStop : okTop($Duration)
	}
	Goto wait
	
	State timeFinish{
		forward waitercleaner -m endtime : endtime(endtime)
	}
	Goto wait
}
</pre></br></br>

<b>teatables.qak</b></br></br>

<pre>
System subtearoom


Dispatch occupy  : occupy(N)
Dispatch release : release(N)
Dispatch clean   : clean(N)

Request isClean : isClean(N)
Reply isCleanDone : isCleanDone(N,E)

Dispatch setTableState : setTableState(N,S)

Request tableState : tableState(N)
Reply state : state(N,S)

Context ctxtearoom_teatables ip [host="192.168.0.38" port=8045] 

QActor teatables context ctxtearoom_teatables{ 
[#
	var StateOfTables = ""
	var E = ""
	var Table = ""
#]
	State s0 initial{
		println("teatables START")
		solve( consult("tearoomkb.pl")	 )
	}
	Goto work
	
	State work{
		solve( stateOfTeatables(S) )
		ifSolved { [# StateOfTables = getCurSol("S").toString() #] }
		println("teatables s0: $StateOfTables")
		updateResource [# StateOfTables #]
	}
	Transition t0  whenMsg occupy -> engageTable
					whenMsg clean -> cleanTable
					whenMsg release -> release
				whenRequest isClean -> replyClean
					whenMsg setTableState -> setState
					whenRequest tableState -> tableState
					
					
	State release {
		println("teatables   |||   release")
		onMsg(release : release(N)){
			forward teatables -m setTableState : setTableState(S,dirty)
		}
	}
	Goto work
	
	State tableState{
		println("teateables   |||   tableState")
		onMsg(tableState : tableState(N)){
			[# Table = payloadArg(0) #]
			solve( getState(N,S))
			ifSolved{
				[# E = getCurSol("S").toString() #]
			}
			replyTo tableState with state : state($Table,$E)
		}
	}
	Goto work
					
	State setState{
		println("teatables   |||   setState")
		onMsg(setTableState : setTableState(N,S)){
			solve( setState(N,S) )
		}
	}
	Goto work
					
	State replyClean {
		println("teatables   |||   replyClean")
		onMsg(isClean : isClean(N)){
			[# Table = payloadArg(0) #]
			println("onMsg isClean")
			solve( getState(N,S) )
			ifSolved{
				[# 
					E = getCurSol("S").toString()
					if(E == "clean")
						E = "yes"
					else
						E = "no"
				#]
			}
			replyTo isClean with isCleanDone : isCleanDone($Table,$E)
			println("replyTo isClean $E")
		}
	}
	Goto work
					
	State engageTable{
		printCurrentMessage
		onMsg( occupy : occupy(N) ){
			println("engageTable ${payloadArg(0)}")
			solve( occupyTable( $payloadArg(0) ))
			solve( stateOfTeatables(S) )
			[# StateOfTables = getCurSol("S").toString() #]  
			println("teatables engageTable ${payloadArg(0)}: $StateOfTables")
			updateResource [# StateOfTables #]
		}
	}
	Goto work

	State cleanTable{
		printCurrentMessage
		onMsg( clean : clean(N) ){
			println("clean ${payloadArg(0)}")
			solve( cleanTable( $payloadArg(0) ) )	//could do anything
			solve( stateOfTeatables(S) )
			[# StateOfTables = getCurSol("S").toString() #]  
			println("teatables cleanTable ${payloadArg(0)}: $StateOfTables")
			updateResource [# StateOfTables #] 			 
		}
	}
	Goto work
}
</pre>

</br></br>
TestPlan:</br>

Lo scopo principale di questo test plan sarà quello di verificare che il <em>clean</em> venga interrotto correttamente e che 
lo stato del tavolo rimanga aggiornato all'ultimo incontrato, mantenendo anche il tempo rimasto nel timer, così da permettere al <em>waiter</em> di riprendere 
il lavoro da dove l'ha interrotto. </br>
In questo test plan dovremo controllare che:
<ul>
    <li>Il <em>waiter</em> interrompa il task se lo stato del tavolo non ha ancora raggiunto "sanitized" </li>
    <li>il <em>waiter</em> NON interrompa il task <em>clean</em> se lo stato ha già raggiunto "sanitized" </li>
    <li>il <em>waiter</em> riprenda il task <em>clean</em> dall'ultimo stato raggiunto con il tempo rimasto in precedenza </li>
	
</ul><br>
Il test plan seguente utilizza un'entità Expected per gestire il valore atteso ed effettuare il check.
Tramite le sue variabili cleanStopped, tablePrevState e cleanRemainingTime potremo verificare se la clean è 
ferma o no, se la clean riparte dallo stato precedente all'interruzione e se il tempo rimasto è uguale
a quello registrato prima dell'interruzione.
Verrà simulato un cliente nella <em>tearoom</em> e tutto il processo che lo porta fino ad uscire; successivamente un cliente
chiederà di entrare quando il waiter fa il task clean, il quale deve essere interrotto e ripristinato dopo aver portato il nuovo cliente al tavolo.
Per verificare questo, viene utilizzato il "resource" degli attori QAK. Infatti, quando il clean viene interrotto, la risorsa deve avere
il valore atteso che si trova dentro Expected.xxx. <br>
</br>
<pre>
package test
import Expected

class TestWaiterTableStates {
	var waitermind            : ActorBasic? = null
	var waitercleaner         : ActorBasic? = null 
	var teatables         	  : ActorBasic? = null
	val initDelayTime     = 1000L

	val enter = MsgUtil.buildRequest("waitermind","enter","enter","waitermind")
	val clientready = MsgUtil.buildDispatch("waitermind","clientready","clientready","waitermind")	
	val drinkready = MsgUtil.buildDispatch("waitermind","drinkready","drinkready","waitermind")
	val paymentready = MsgUtil.buildDispatch("waitermind","paymentready","paymentready","waitermind")
	
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Before
	fun systemSetUp() {
   		kotlin.concurrent.thread(start = true) {
			it.unibo.ctxtearoom.main()
		}
	}

	@After
	fun terminate() {
		println("%%%  TestWaiter terminate ")
	}
	
	fun checkStop(){
		if(waitermind!=null)
			assert(waitermind!!.geResourceRep()==Expected.cleanStopped)
	}
	
	fun checkCleaning(){ //controllo che NON sia in stop
		if(waitermind!=null)
			assert(waitermind!!.geResourceRep()!=Expected.cleanStopped)
	}
	
	fun checkPrevState(int table){	//controllo che riprenda la clean dallo stato precedente
		if(teatables!=null)
			assert(teatables!!.getState()==Expected.tablePrevState)
	}
	
	fun checkRemainingTime(){	//controllo che il timer segni il tempo effettivamente rimasto
		if(waitercleaner!=null)
			assert(waitercleaner!!.getRemainingTime()<=Expected.cleanRemainingTime)
	}
	
	@Test
	fun testRobotboundary(){
	 	runBlocking{
 			while( waitermind == null ){
				println("testWaiterPosition waits for waitermind ... ")
				delay(initDelayTime)  //time for robot to start
				waitermind = it.unibo.kactor.sysUtil.getActor("waitermind")
				waitercleaner = it.unibo.kactor.sysUtil.getActor("waitercleaner")
				teatables = it.unibo.kactor.sysUtil.getActor("teatables")
 			}
			
			MsgUtil.sendMsg(enter,waitermind!!)
 			delay(15000)
			MsgUtil.sendMsg(clientready,waitermind!!)
			delay(15000)
			MsgUtil.sendMsg(drinkready,waitermind!!)
			delay(15000)
			MsgUtil.sendMsg(paymentready,waitermind!!)
			delay(10000)
			MsgUtil.sendMsg(enter,waitermind!!)	//INTERROMPO LA CLEAN
			
			//subito dopo l'interruzione ho bisogno di sapere lo stato a cui era rimasto il tavolo
			Expected.tablePrevState = teatables.getState(0)	//SALVATAGGIO in Expected.tablePrevState, param: tavolo
			//allo stesso modo salvo il tempo rimasto
			Expected.cleanRemainingTime = waitercleaner.getRemainingTime()
 			delay(8000)
			checkStop()	//controllo che il waiter abbia interrotto la clean
			delay(10000)
			checkCleaning()	//controllo che riprenda la clean
			checkRemainingTime()//controllo che il timer segni il tempo effettivamente rimasto
			checkPrevState(0)	//controllo che riprenda la clean dallo stato precedente
			
			delay(20000)
			//controllo che una volta raggiunto sanitized NON interrompa la clean
			MsgUtil.sendMsg(enter,waitermind!!)
			checkCleaning() //controllo semplicemente se sta continuando a pulire
			
			MsgUtil.sendMsg("end","end","end",waitermind!!)
 			if( waitermind != null ) waitermind!!.waitTermination()
  		}
	 	println("testWaiterPosition BYE  ")  
	}
}
</pre>
<pre>
object Expected{
	val cleanStopped = "cleanStopped"
	var tablePrevState = "dirty"
	var cleanRemainingTime = 150000
}
</pre>
</div>	

<h2>Sprint review</h2> 
<div class="remark">

</div>

<h2>Sprint retrospective</h2> 
<div class="remark">

</div>

</div>



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>