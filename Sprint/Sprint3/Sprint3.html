<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint 3</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>. </li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	

</div>
<h2>Requirement Analysis</h2>
<div class="remark">
<em>Maxstaytime</em>: Viene inteso come tempo che il cliente ha a disposizione per effettuare la sua consumazione nella <em>tearoom</em>.
Il suo funzionamento viene spiegato nelle <a href="./ConsiderazioniIniziali.html"><b>considerazioni iniziali</b></a></br></br>
<em>Smartbell</em>: Entità esterna al waiter atta a notificare l'intenzione di un cliente ad entrare nella tearoom.
	I suoi compiti sono di misurare la temperatura del cliente e, nel caso sia inferiore a 37.5 gradi, assegnargli un identificativo univoco e notificare il waiter.</br></br>
<em>Clientidentifier</em>: Rappresenta un ID univoco assegnato ai clienti dallo smartbell in caso di almeno un tavolo libero e clean</br></br>
<em>inform</em>: Azione svolta dal waiter atta ad informare il cliente del tempo massimo di attesa prima che un tavolo risulti nuovamente libero e clean</br></br>
<em>Current state</em>: Rappresenta lo stato della <em>tearoom</em>, viene definito dallo stato dei tavoli (occupied, dirty, clean...), dallo stato del waiter e dallo stato del barman.</br></br>
per altri termini, link agli sprint precedenti</br></br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/SprintIniziale">Sprint 1</a>
</br></br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint2">Sprint 2</a>
</br></br>

<b>VECCHIE ASSUNZIONI</b> 
<ul>
<li>Nel sistema esistono solo due clienti, un cliente entra quando il waiter sta facendo il clean. Il secondo cliente non interagisce.</li>
</ul>
<b>NUOVE ASSUNZIONI</b>
<ul>
<li>il barman prepara un ordine alla volta</li>
<li>i tempi di preparazione sono sempre gli stessi</li>
<li>il cliente suona una volta sola e aspetta il suo turno.</li>
</ul>
Al fine di modellare i requisiti imposti con il rilassamento della maggior parte delle assunzioni, è necessario gestire
l'ingresso di due clienti alla volta, oltre a modellare il task <em>inform</em> nel caso in cui 
un terzo cliente chieda di entrare; è necessario modellare il funzionamento dello <em>smartbell</em> con le
azioni di controllo temperatura. E' inoltre necessario modellare la webapp per la visualizzazione del <em>currentstate</em> della tearoom.
Infone, è necessario gestire il maxstaytime, in modo tale da modellare situazioni in cui il tempo concesso ad un cliente scade e quest'ultimo deve
essere accompagnato all'uscita, dopo l'eventuale pagamento.
</br></br>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint3/TerzoSprintAnalReq">Link al modello dell'analisi dei requisiti</a>
</br></br>
<b>TEST PLAN</b></br>
<ul>
<li>Verifichiamo che se un cliente ha temperatura > 37,5° non venga accettato nella <em>tearoom</em></li>
<li>Simuliamo un cliente che esaurisca il <em>maxstaytime</em> e di conseguenza verifichiamo che il <em>waiter</em>
richieda il pagamento e lo accompagni fuori.</li>
</ul>

<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint3/TerzoSprintAnalReq/test">Test plan</a>

</div>

<h2>Problem analysis</h2> 
<div class="remark">
</br>
<b>Prolematiche sorte a seguito dell'analisi dei requisiti</b>
<ul>
	<li><b>Problema 1</b>: Gestione delle richieste da tavoli differenti:</br>
            Il waiter ha la necessità di sapere a che tavolo portare l'ordinazione.
	</li></br>    
	<li><b>Problema 2</b>: Interruzione del clean solo se c'è un altro tavolo disponibile: nello sprint precedente abbiamo assunto
    che vi fosse solo un cliente alla volta nella tearoom, quindi questo problema non si presentava.
    </li></br>
	<li><b>Problema 3</b>: il tempo trascorre solo quando è responsabilità del cliente ovvero nel suo turno.
		Per tale motivo sorge la problematica in cui il cliente richiede o di ordinare o il conto mentre il waiter sta gia facendo un'azione. 
		La richiesta sarà gestita solo quando l'azione corrente si conclude e quindi il timer viene fermato solo dopo aver ultimato quell'azione.
		Il tempo che intercorre tra la richiesta del cliente e l'azione del waiter in risposta alla richiesta viene considerato trascurabile. 
	</li></br>
	<li><b>Problema 4</b>: 
		Se i due clienti sono entrati e non ordinano, i timer sono entrambi attivi, questo scenario introduce la necessità di gestire più "entità" timer contemporaneamente.
		Diventa opportuno introdurre un'entità intermedia, la quale spartisce le interazioni tra waitermind e i vari timer di ciascun cliente. Così facendo,
		introduciamo un livello a metà che gestisce le richiesta dal waitermind alle varie entità timer, ciò risulta in maggiore scalabilità e riusabilità di waitermind
	</li></br>
	<li><b>Problema 5</b>: Gestione dei tempi di attesa per l'azione di <em>inform</em> a seguito del rilassamento sui vincoli sul numero di clienti presenti nel sistema (interni ed esterni alla tearoom). 
		Esistono 3 situazioni in cui si può trovare la tearoom,</br>
		   &ensp;&ensp;- Due tavoli non cleaned : tempo di attesa equivale a min{cleaningTimeTable1,cleaningTimeTable2}</br>
		   &ensp;&ensp;- Un tavolo non cleaned e un cliente dentro : azione del waiter rivolte ai clienti più prioritari, remainingClientTime</br>
		   &ensp;&ensp;- Due clienti dentro la tearoom : tempo di attesa equivale a min{remainingClientTime1,remainingClientTime2} </br>
		   cleaningTimeTable definito come il tempo residuo per la pulizia del tavolo, </br>
		   remainingClientTime definito come il tempo residuo del cliente per il suo staytime.
	</li></br>
	<li><b>Problema 6</b>: Gestione del currentstate:</br>
		Dalla gestione dello stato globale della stanza è nata la necessità di introdurre un'entità che gestisca lo stato sulla base di conoscenza per questioni di modularità, un unico observer per lo stato della stanza.
		Quindi, è stato rimodellato l'attore <i>teatables</i> in modo da gestire anche gli stati
		del waiter e del barman, per avere un unico punto di accesso per le informazioni.
	</li></br>
	</ul>
	<b> Descrizione formale delle entità a seguito della descrizione delle problematiche</b></br></br>
		<ul>
		<u>Valore maxstaytime</u>: valore utilizzato per rappresentare la quantità massima di tmpo a cui un cliente è permesso soggiornare nella tearoom. 
		Questo valore è incrementale nel tempo ed è rappresentato simil contatore il cui valore massimo che potrà raggiungere sarà maxstaytime. 
		Durante il turno di decisione del cliente, il contatore verrà attivato e contestualmente verrà bloccato una volta fatta la richiesta da cliente a waiter.
		Per semplificare l'accesso al valore maxstaytime di ogni cliente è stato introdotto un attore (broker) chiamato <i>maxstaytimer</i> il quale gestirà la 
		terminazione del tempo concesso ad ogni cliente inviando al waitermind un dispatch di transizione verso lo stato di <em>collect</em>.
		L'attore <i>maxstaytimer</i> si avvale di due attori, ciascuno dei quali gestisce a sua volta il tempo trascorso per ogni cliente nella tearoom. (Problema 3 e Problema 4)</br></br>
		
		<u>Entità smartbell</u>: viene modellata come un attore qak, vedi scelta modelli in <a href="./../SprintIniziale/SprintIniziale.html"><b>considerazioni iniziali</b></a> che 
		invia una request al waiter per l'ingresso di un cliente, il waiter risponderà con una reply in caso di accettazione di richiesta o in caso contrario 
		(rifiuto per mancanza di tavoli liberi e puliti) con un inform rappresentante il tempo di attesa prima di un ingresso.</br></br>
		
		<u>Identificativo clientidentifier</u>: valore numerico univoco per cliente, generato da <em>smartbell</em> a seguito di una richiesta di ingresso di un cliente. (Problema 1)</br></br>
		
		<u>Task inform</u>: task che consiste in una reply fatta a seguito di una richiesta di ingresso da parte di un cliente in caso di tearoom sprovvista di tavoli cleaned.
		La reply del waiter contiene al suo interno un valore numerico corrispondente ai secondi di attesa massima per l'ingresso del cliente. (Problema 5) </br> </br>
		
		<u>Current state</u>: stato della tearoom ricavato dall'attore <i>tearoomstate</i>, il quale interagisce tra le varie entità del sistema e la base di conoscenza.
		I dispatch in ingresso a <i>tearoomstate</i> sono provenenti dal <em>waiter</em> e dal <em>barman</em> e contengono le informazioni relative allo stato dei tavoli, del waiter e del barman. </br>
		L'attore <i>tearoomstate</i> interagisce mediante updateresource per comunicare alla webapp lo stato della tearoom.<!--Accesso alle risorse mediante COAP request via browser/plugin <u>perchè</u>--> (Problema 6)  </br></br>
		</ul>
<b>Dato il rilassamento delle assunzioni rispetto agli sprint precedenti, sorte nuove situazioni</b>
<ul>
	<li>Situazione 1: gestione di più clienti contemporaneamente e delle loro rispettive richieste.</li>
    <li>Situazione 2: un cliente non viene ammesso perchè la sua temperatura è superiore a 37,5°.</li>
    <li>Situazione 3: un cliente esaurisce il <em>maxstaytime</em> e quindi viene richiesto 
    il pagamento dal waiter e viene accompagnato all'uscita.</li></br>
</ul>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint3/TerzoSprintAnalProb">Link al modello dell'analisi del problema</a>
</br></br>
<b>TEST PLAN</b></br>
</br>
Testiamo la corretta funzione delle situazioni 1, 2 e 3.
<ul>
<li>Situazione in cui ci sono due clienti, uno dei quali chiede un ordine. Il waiter deve andare al tavolo giusto.</li>
<li>Situazione in cui è in atto un clean e viene simulata una richiesta di ingresso. Il clean non deve essere fermato, in quanto non è possibile accogliere, in quel momento, il nuovo cliente.</li>
<li>Verifichiamo che se un cliente ha temperatura > 37,5° non venga accettato nella <em>tearoom</em></li>
<li>Simuliamo un cliente che esaurisca il <em>maxstaytime</em> e di conseguenza verifichiamo che il <em>waiter</em>
richieda il pagamento e lo accompagni fuori.</li>
<li>Nel caso in cui un cliente chieda di entrare e non ci sono tavoli liberi, esso deve essere informato del massimo tempo di attesa con <em>inform</em></li>
<li>Verificare la corretta gestione del Current State</li>
</br>
</ul>
<a href="https://github.com/paolopiano1997/tema_finale_ISS_verdini_farina_turra/tree/master/Sprint/Sprint3/TerzoSprintAnalProb/test">Test plan</a>
</br></br>
<b>SVILUPPI FUTURI</b>
<ol>
    <li>Il barman potrebbe preparare due ordini insieme, presumibilmente uguali, quindi
    il waiter potrebbe portare direttamente gli ordini ad entrambi i tavoli.</li>
    <li>Opzionale: Nella hall ci può essere al più una persona</li>
    <li>Problema 1: Se il cliente suona ma poi se ne va?</li>
    <li>Problema 2: Se il cliente suona molte volte?</li>
    <li>Tenere una cassa: dove i pagamenti dei clienti si sommano e si mostra il guadagno giornaliero.</li>
    <li>Tenere un menù con la lista dei prezzi e in base all'ordine variare la somma da pagare</li>
</ol>

</div>	

<h2>Sprint review</h2> 
<div class="remark">

</div>

<h2>Sprint retrospective</h2> 
<div class="remark">

</div>

</div>



<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>