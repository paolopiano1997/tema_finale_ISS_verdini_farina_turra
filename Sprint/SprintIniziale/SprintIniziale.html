<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint Iniziale</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>,:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>.</li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	


</div>
<h2>Requirement analysis</h2>
<div class="remark">
Con riferimento alle problematiche analizzate in <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>, iniziamo ad analizzare
il sistema considerando questa assunzione:
 <ul>
	<li>Ci sia un solo cliente nel sistema e mentre sto servendo questo cliente non capiti nient'altro. Simuliamo una catena computazionale completa, in cui
	si parte da un cliente che richiede l'accesso, fino alla sua uscita e relativa <em>clean</em> del tavolo.</li>
</ul>
A seguito di questa assunzione, le considerazioni fatte precedentemente rimangono invariate.
Poichè il <em>barman</em> deve interagire con il <em>waiter</em>, ricevere e preparare gli ordini, è opportuno
modellarlo in un primo momento come un attore esterno. Il cliente è per ora simulato mediante la ricezione della request per entrare nella <em>tearoom</em>
</br>
Di seguito è stato modellato un primo sistema seguendo i requisiti e l'assunzione.
E' opportuno considerare che il task <em>inform</em> non è da modellare, in quanto per l'assunzione fatta non potrà
mai verificarsi. E' stato predisposto un oggetto "Table" che rappresenta lo stato di ciascun tavolo presente nella stanza.
E' stato opportuno creare dei dispatch che modellano:
<ul>
<li>Intenzione del cliente a ordinare: clientready</li>
<li>Drink pronto dal barman: drinkready</li>
<li>Cliente pronto a pagare: paymentready</li>
<li>Ordine trasmesso al <em>barman</em>: order</li>
</ul>
La richiesta e risposta del cliente e del <em>waiter</em> per entrare nella <em>tearoom</em> sono state modellate, in QAK, come 
una Request/Reply.

<pre>
System tearoom

Request enter : enter(ID)
Reply accept : accept(C)

Dispatch drinkready : drinkready(V)
Dispatch clientready : clientready(C)
Dispatch paymentready : paymentready(P)
Dispatch order : order(O)
Dispatch end : end (V)

Context ctxwaiter ip [ host="localhost" port=8068 ] 

ExternalQActor barman context ctxwaiter

QActor waiter context ctxwaiter {
[#
	val	Cleantime = 3000L
	data class Table(var state: String ="cleaned") {
		
	}
	val table1 = Table()
	val table2 = Table()
#]
	State s0 initial {
		discardMsg Off
		println("Waiter    |||   init")
	}
	Goto home
	
	State home{
		println("waiter    |||   home")
		updateResource [# "home" #]
	}
	Transition t0 whenRequest enter -> accept
				  whenMsg clientready -> take
				  whenMsg drinkready -> serve
				  whenMsg paymentready -> collect
				  whenMsg end -> endwork
	
	
	State accept {
		println("waiter    |||   accept")
		replyTo enter with accept : accept(idclient)
	}
	Goto reachEntranceDoor
	
	State reachEntranceDoor {
		println("waiter    |||   reachEntranceDoor")
		updateResource[# "reachEntranceDoor" #]
		delay 2000
	}
	Goto convoyToTable
	
	State convoyToTable{
		println("waiter    |||   convoyToTable")
		updateResource [# "convoyToTable" #]
		delay 3000
	}
	Goto home
	
	State take{
		println("waiter   |||   take")
		updateResource [# "take" #]
		onMsg ( clientready : clientready(C)) {
			forward barman -m order : order(payloadArg(0))
		}
		delay 2000
	}
	Goto home
	
	State serve{
		println("waiter   |||   serve")
		updateResource[# "serve" #]
		delay 3000
	}
	Goto home
	
	State collect {
		println("waiter   |||   collect")
		updateResource[# "collect" #]
		delay 4000
	}
	Goto convoyToExitDoor
	
	State convoyToExitDoor{
		println("waiter   |||   convoyToExitDoor")
		updateResource[# "convoyToExitDoor" #]
		[# table1.state = "dirty" #]
		delay 5000
	}
	Goto clean
	
	State clean{
		println("waiter   |||   clean")
		updateResource[# "clean1" #]
		delayVar Cleantime
		[# table1.state = "undirty" #]
		println("waiter   |||   table state undirty")
	}
	Goto clean2
	
	State clean2{
		println("waiter   |||   clean2")
		updateResource[# "clean2" #]
		delayVar Cleantime
		[# table1.state = "sanitized" #]
		println("waiter   |||   table state sanitized")
	}
	Goto clean3
	
	State clean3{
		println("waiter   |||   clean3")
		updateResource[# "clean3" #]
		delayVar Cleantime
		[# table1.state = "cleaned" #]
		println("waiter   |||   table state cleaned")
	}
	Goto home
	
	State endwork{
		terminate 0
	}
}
</pre>


</div>


<h2>Problem analysis</h2> 
<div class="remark">
Sempre con riferimento all'assunzione effettuata e alle <a href="./ConsiderazioniIniziali.html">riflessioni</a>, è opportuno 
modellare i tavoli come stato interno al <em>waiter</em>. Dopo avere identificato gli stati in cui un tavolo può trovarsi,
ovvero "occupied", "dirty", "undirty", "sanitized" e "cleaned", è necessario analizzare come questi stati vengono cambiati nel tempo.
Un tavolo è nello stato "cleaned" in partenza, il che significa pronto per accogliere un nuovo cliente; lo stato "occupied" è dovuto ad una problematica
relativa al fatto che il <em>waiter</em> deve sapere anche quando un tavolo è occupato attualmente da un cliente, non solo se il tavolo sia sporco o meno; lo stato "dirty" viene raggiunto
alla fine del pagamento e uscita di un cliente da quel tavolo; gli altri stati rimangono invariati dall'analisi precedente.
</br>
</br>
Una problematica fondamentale risiede nelle operazioni da svolgere, oltre che alla gestione dei messaggi da parte del <em>waiter</em>.
Infatti, parliamo della parte proattiva e della parte reattiva; tale problematica induce la fattorizzazione del <em>waiter</em> in due principali entità:
<ul>
<li>Motore</li>
<li>Mente</li>
</ul>
Il motore è l'entità che si occupa del movimento, una delle principali caratteristiche del <em>waiter</em>. Il movimento è un concetto chiave in questo sistema,
considerando per esempio i task <em>reach and convoy</em>, ma anche <em>serve</em>. Tutti questi task vengono effettivamente portati a termine grazie al movimento.
Ecco che la problematica del movimento diventa rilevante: è opportuno modellarlo come entità a sè stante, in quanto non ha niente a che vedere con interazioni e messaggi.
In tale contesto è opportuno introdurre un'entità <em>planner</em>, che identifica un pianificatore di movimento, ovvero un'entità la quale viene informata
riguardo a un punto da raggiungere, viene innescata e ha come scopo andare nel punto prefissato. A tal fine, questo <em>planner</em> identifica la <em>tearoom</em> come un insieme
di celle con una determinata posizione X e Y.
Risulta quindi necessario introdurre dei messaggi aggiuntivi, al fine di coordinare mente e motore:
<ul>
<li>moveto(X,Y): messaggio che la mente manda all'engine per spostarti alla cella in posizione X,Y. Opportunamente modellato come Request, affinchè la mente riceva una Reply di quando e se l'engine ha raggiunto tale posizione.</li>
<li>done(X,Y): messaggio che l'engine manda alla mente in risposta al moveto, in cui afferma di essere arrivato alla cella di posizione X,Y. Opportunamente modellato come Reply.</li>
<li>start: è necessario che la mente "inizializzi" l'engine, il quale dovrà dare un feedback su quando è pronto per effettuare operazioni. Quindi tale messaggio è modellato come Request, a cui corrisponderà la seguente Reply</li>
<li>ready: messaggio Reply che l'engine manda alla mente per affermare che è pronto all'opera.</li>

</ul>
	
</div>	

</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>