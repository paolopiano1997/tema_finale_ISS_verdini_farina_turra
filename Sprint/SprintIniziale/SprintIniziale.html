<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<!-- saved from url=(0129)http://htmlpreview.github.io/?https://github.com/anatali/iss2020LabBo/blob/master/it.unibo.issLabStart/userDocs/template2020.html -->
<html><!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/htmlpreview" src="../css/issStyle.js"></script>
--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 110%;
}

h3 {
	background-color: #e6ccff;
    font-size: 80%;
}
h4 {
    background-color: #99ffcc;
    font-size: 100%;
	width: 750px;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	width: 800px;
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<!--<base href="https://raw.githubusercontent.com/anatali/iss2020LabBo/master/it.unibo.issLabStart/userDocs/template2020.html">--><base href=".">
   
<title>Sprint Iniziale</title></head>
    
<body>
<h2>Introduction</h2>
 The <em>manager</em> of a <em>tearoom</em> intends to regulate the access to the service by means of a ddr robot (<em>waiter</em>).
<br/><br/>
The <em>tearoom</em> is a rectangular room that includes:

<ul>
<li>an <em>entrancedoor</em> to enter in the room and an <em>exitdoor</em> to exit form it;</li>
<li>a number <tt>N (N=2)</tt> of <em>teatable</em>;</li>
<li>a <em>serviceare</em> including a <em>servicedesk</em> at which works a <em>barman</em>;</li>
<li>a <em>hall</em> equipped with a <em>presencedetector</em>, i.e. a device (e.g. a sonar) that can detect the presence of 
a person (or some other entity) in it.</li>
</ul>

The <em>waiter</em> can freely move along the borders of the tearoom, since there are no obstacles there. 

<center><img src="tearoom20.png" alt="tearoom20.png" width="75%" height="32%"/></center>


<h3>User stories</h3>
As a <em>client</em>,:
<ul>
<li>I intend to <em>notify</em> my interest in <em>entering</em> in a <em>safe tearoom</em>, <em>sitting</em> at a free teatable,  <em>ordering</em> 
some tea,  <em>consuming</em> it  (within a limited amount of time <em>maxstaytime</em>)  <em>paying</em> the service
with my credit card and finally <em>leaving</em> the room.</li>
<li>For <em>safe tearoom</em>, I intend a tearoom with <em>clean</em> tea-tables posed at a proper distance; the room is populated by human clients 
whose body temperature is less than <tt>37.5</tt> degrees. </li>
<li>I can submit my notification of interest by hitting the <em>smartbell</em> located near the  <em>entrancedoor</em> 
that will automatically measure my body temperature and send a request message to the <em>waiter</em>, by giving to me an unique <em>clientidentifier</em>.
</li>
<li>I my body temperature is ok, but my request cannot be immediately satisfied (since the room is full), I will be <em>informed</em> by the <em>waiter</em> 
aabout the maximum waiting time.</li>
</ul>

As a <em>manager</em>:
<ul>
<li>I intend to be able to see the <em>current state</em> of the <em>tearoom</em> by using  a browser connected to a web-server 
associated to the application.
</li>
</ul>

 
<h2>Requirements</h2>
 
<div class="remark">
The <em>waiter</em> should perform the following tasks:
<ul>
 
<li><em>accept</em> the request of a client to enter in the tearoom if there is at least one teatable in the state <em>tablelean</em>, i.e.
the table is free and has been properly cleaned; </li>
<li><em>inform</em> the client about the maximum waiting time if there is no <em>tableclean</em>;</li> 
<li><em>reach</em> the <em>entrance door</em> and <em>convoy</em> the accepted client to the selected teatable;</li>
<li><em>take</em> the order of the client and transmit it (using a wifi-device) to the <em>barman</em>; </li>
<li><em>serve</em>  the client when the <em>barman</em> says that the requested drink is ready;</li>
<li><em>collect</em> the payment from the client when he/she has finished to consume or when the <em>maxstaytime</em> is expired;</li>
<li><em>convoy</em> the client to the <em>exitdoor</em>;</li>
<li><em>clean</em> the tea-table just freed  by the client;</li>
<li><em>rest</em> at my <em>home</em> when there is nothing to do.</li>
</ul>

Since the room could contain <tt>N</tt> clients at the time, the <em>waiter</em> should reduce as much as possible the waiting time
of the requests coming from each client.
   
<h3>Optional: one client in the hall</h3>
The <em>waiter</em> must open the <em>exitdoor</em> only when the hall is free, i.e. it must
not open that door if the hall is already engaged by a client waiting to enter at the <em>entrancedoor</em>.   

<h2>Non functional requirements</h2>  
<ol>
<li>The ideal work team is composed of 3 persons. Teams of 1 or 2 persons (<bc>NOT</bc> 4 or more) are also allowed. </li>
<li>The team must present a workplan as the result of the requirement/problem analysis,
including some significant <bc>TestPlan</bc>.</li>
<li>The team must present the sequence of SPRINT performed, with appropriate motivations.</li>
<li>The team must present (in synthetic, schematic way) the specific activity of each team-component.</li>
</ol>	


</div>
<h2>Requirement analysis</h2>
<div class="remark">
Con riferimento alle problematiche analizzate in <a href="./ConsiderazioniIniziali.html"><b>riflessioni</b></a>, iniziamo ad analizzare
il sistema considerando questa assunzione:
 <ul>
	<li>Ci sia un solo cliente nel sistema e mentre sto servendo questo cliente non capiti nient'altro. Simuliamo una catena computazionale completa, in cui
	si parte da un cliente che richiede l'accesso, fino alla sua uscita e relativa <em>clean</em> del tavolo.</li>
</ul>
A seguito di questa assunzione, le considerazioni fatte precedentemente rimangono invariate.
Poichè il <em>barman</em> deve interagire con il <em>waiter</em>, ricevere e preparare gli ordini, è opportuno
modellarlo in un primo momento come un attore esterno. Il cliente è per ora simulato mediante la ricezione della request per entrare nella <em>tearoom</em>
</br>
Di seguito è stato modellato un primo sistema seguendo i requisiti e l'assunzione.
E' opportuno considerare che il task <em>inform</em> non è da modellare, in quanto per l'assunzione fatta non potrà
mai verificarsi. E' stato predisposto un oggetto "Table" che rappresenta lo stato di ciascun tavolo presente nella stanza.
E' stato opportuno creare dei dispatch che modellano:
<ul>
<li>Intenzione del cliente a ordinare: clientready</li>
<li>Drink pronto dal barman: drinkready</li>
<li>Cliente pronto a pagare: paymentready</li>
<li>Ordine trasmesso al <em>barman</em>: order</li>
</ul>
La richiesta e risposta del cliente e del <em>waiter</em> per entrare nella <em>tearoom</em> sono state modellate, in QAK, come 
una Request/Reply.

<pre>
System tearoom

Request enter : enter(ID)
Reply accept : accept(C)

Dispatch drinkready : drinkready(V)
Dispatch clientready : clientready(C)
Dispatch paymentready : paymentready(P)
Dispatch order : order(O)
Dispatch end : end (V)

Context ctxwaiter ip [ host="localhost" port=8068 ] 

ExternalQActor barman context ctxwaiter

QActor waiter context ctxwaiter {
[#
	val	Cleantime = 3000L
	data class Table(var state: String ="cleaned") {
		
	}
	val table1 = Table()
	val table2 = Table()
#]
	State s0 initial {
		discardMsg Off
		println("Waiter    |||   init")
	}
	Goto home
	
	State home{
		println("waiter    |||   home")
		updateResource [# "home" #]
	}
	Transition t0 whenRequest enter -> accept
				  whenMsg clientready -> take
				  whenMsg drinkready -> serve
				  whenMsg paymentready -> collect
				  whenMsg end -> endwork
	
	
	State accept {
		println("waiter    |||   accept")
		replyTo enter with accept : accept(idclient)
	}
	Goto reachEntranceDoor
	
	State reachEntranceDoor {
		println("waiter    |||   reachEntranceDoor")
		updateResource[# "reachEntranceDoor" #]
		delay 2000
	}
	Goto convoyToTable
	
	State convoyToTable{
		println("waiter    |||   convoyToTable")
		updateResource [# "convoyToTable" #]
		delay 3000
	}
	Goto home
	
	State take{
		println("waiter   |||   take")
		updateResource [# "take" #]
		onMsg ( clientready : clientready(C)) {
			forward barman -m order : order(payloadArg(0))
		}
		delay 2000
	}
	Goto home
	
	State serve{
		println("waiter   |||   serve")
		updateResource[# "serve" #]
		delay 3000
	}
	Goto home
	
	State collect {
		println("waiter   |||   collect")
		updateResource[# "collect" #]
		delay 4000
	}
	Goto convoyToExitDoor
	
	State convoyToExitDoor{
		println("waiter   |||   convoyToExitDoor")
		updateResource[# "convoyToExitDoor" #]
		[# table1.state = "dirty" #]
		delay 5000
	}
	Goto clean
	
	State clean{
		println("waiter   |||   clean")
		updateResource[# "clean1" #]
		delayVar Cleantime
		[# table1.state = "undirty" #]
		println("waiter   |||   table state undirty")
	}
	Goto clean2
	
	State clean2{
		println("waiter   |||   clean2")
		updateResource[# "clean2" #]
		delayVar Cleantime
		[# table1.state = "sanitized" #]
		println("waiter   |||   table state sanitized")
	}
	Goto clean3
	
	State clean3{
		println("waiter   |||   clean3")
		updateResource[# "clean3" #]
		delayVar Cleantime
		[# table1.state = "cleaned" #]
		println("waiter   |||   table state cleaned")
	}
	Goto home
	
	State endwork{
		terminate 0
	}
}
</pre>

Come testplan è stato effettuato un controllo sullo stato del <em>waiter</em> in risposta alle richieste ed operazioni che deve svolgere,
per esempio controllando che quando accetta una richiesta si rechi alla porta di ingresso, oppure quando accompagna il cliente al tavolo stia effettivamente andando verso il tavolo.

<pre>
class TestWaiter {
	var waiter            : ActorBasic? = null
	//val mqttTest   	      = MqttUtils("test") 
	val initDelayTime     = 1000L
	
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Before
	fun systemSetUp() {
   		kotlin.concurrent.thread(start = true) {
			it.unibo.ctxwaiter.main()
		}
	}

	@After
	fun terminate() {
		println("%%%  TestWaiter terminate ")
	}
	
	fun checkReachEntranceDoor(value: String){		
		if( waiter != null ){
			println(" --- checkReachEntranceDoor --- ${waiter!!.geResourceRep()}")
			assertTrue( waiter!!.geResourceRep() == value)
		}  
	}
	
	fun checkReachTable(value: String){		
		if( waiter != null ){
			println(" --- checkReachTable --- ${waiter!!.geResourceRep()}")
			assertTrue( waiter!!.geResourceRep() == value)
		}  
	}
	
	fun checkWait(value: String){		
		if( waiter != null ){
			println(" --- checkWait --- ${waiter!!.geResourceRep()}")
			assertTrue( waiter!!.geResourceRep() == value)
		}  
	}
	
	@Test
	fun testRobotboundary(){
	 	runBlocking{
 			while( waiter == null ){
				println("testWaiter wait for waiter ... ")
				delay(initDelayTime)  //time for robot to start
				waiter = it.unibo.kactor.sysUtil.getActor("waiter")
 			}
			
			MsgUtil.sendMsg(MsgUtil.buildRequest("waiter","enter","enter","waiter"),waiter!!)
 			delay(7000)
			checkReachEntranceDoor( "reachingEntranceDoor" )
			MsgUtil.sendMsg("ready","ready","ready",waiter!!)
 			delay(7000)
			checkReachTable( "reachingTable" )
			MsgUtil.sendMsg("ready","ready","ready",waiter!!)
 			delay(7000)
 			checkWait( "home" )
			delay(2000)
			MsgUtil.sendMsg("end","end","end",waiter!!)
 			if( waiter != null ) waiter!!.waitTermination()
  		}
	 	println("testWaiter BYE  ")  
	}
}
</pre>

</div>


<h2>Problem analysis</h2> 
<div class="remark">
Sempre con riferimento all'assunzione effettuata e alle <a href="./ConsiderazioniIniziali.html">riflessioni</a>, è opportuno 
modellare i tavoli come stato interno al <em>waiter</em>. Dopo avere identificato gli stati in cui un tavolo può trovarsi,
ovvero "occupied", "dirty", "undirty", "sanitized" e "cleaned", è necessario analizzare come questi stati vengono cambiati nel tempo.
Un tavolo è nello stato "cleaned" in partenza, il che significa pronto per accogliere un nuovo cliente; lo stato "occupied" è dovuto ad una problematica
relativa al fatto che il <em>waiter</em> deve sapere anche quando un tavolo è occupato attualmente da un cliente, non solo se il tavolo sia sporco o meno; lo stato "dirty" viene raggiunto
alla fine del pagamento e uscita di un cliente da quel tavolo; gli altri stati rimangono invariati dall'analisi precedente.
</br>
</br>
Una problematica fondamentale risiede nelle operazioni da svolgere, oltre che alla gestione dei messaggi da parte del <em>waiter</em>.
Infatti, parliamo della parte proattiva e della parte reattiva; tale problematica induce la fattorizzazione del <em>waiter</em> in due principali entità:
<ul>
<li>Motore</li>
<li>Mente</li>
</ul>
Il motore è l'entità che si occupa del movimento, una delle principali caratteristiche del <em>waiter</em>. Il movimento è un concetto chiave in questo sistema,
considerando per esempio i task <em>reach and convoy</em>, ma anche <em>serve</em>. Tutti questi task vengono effettivamente portati a termine grazie al movimento.
Ecco che la problematica del movimento diventa rilevante: è opportuno modellarlo come entità a sè stante, in quanto non ha niente a che vedere con interazioni e messaggi.
In tale contesto è opportuno introdurre un'entità <em>planner</em>, che identifica un pianificatore di movimento, ovvero un'entità la quale viene informata
riguardo a un punto da raggiungere, viene innescata e ha come scopo andare nel punto prefissato. A tal fine, questo <em>planner</em> identifica la <em>tearoom</em> come un insieme
di celle con una determinata posizione X e Y.
Risulta quindi necessario introdurre dei messaggi aggiuntivi, al fine di coordinare mente e motore:
<ul>
<li>moveto(X,Y): messaggio che la mente manda all'engine per spostarti alla cella in posizione X,Y. Opportunamente modellato come Request, affinchè la mente riceva una Reply di quando e se l'engine ha raggiunto tale posizione.</li>
<li>done(X,Y): messaggio che l'engine manda alla mente in risposta al moveto, in cui afferma di essere arrivato alla cella di posizione X,Y. Opportunamente modellato come Reply.</li>
<li>start: è necessario che la mente "inizializzi" l'engine, il quale dovrà dare un feedback su quando è pronto per effettuare operazioni. Quindi tale messaggio è modellato come Request, a cui corrisponderà la seguente Reply</li>
<li>ready: messaggio Reply che l'engine manda alla mente per affermare che è pronto all'opera.</li>
</ul>
</br>
Poichè il <em>planner</em> lavora su una mappa, ovvero le varie celle che identificano la <em>tearoom</em>, è necessario ragionare, al posto di "movimento" in sè, in termini
di "step", ovvero il movimento unitario del <em>waiter</em> diventa uno step di una cella. E' necessario gestire quindi eventuali "step" falliti in concomitanza di ostacoli (per esempio le pareti della <em>tearoom</em>).

<pre>
</br>
<em>waitermind.qak</em>
</br>
</br>
System tearoom

//Movements messages
Request moveto : moveto(X,Y)
Reply done : done(X,Y)

//Init messages
Request start : start(S)
Reply ready : ready(V)

//Client and tearoom messages
Request enter : enter(ID)
Reply accept : accept(C)
Dispatch drinkready : drinkready(V)
Dispatch clientready : clientready(C)
Dispatch paymentready : paymentready(P)
Dispatch order : order(O)
Dispatch end : end (E)

Context ctxbasicrobot     ip [host="localhost"   port=8020] 
Context ctxtearoom ip [ host="127.0.0.1" port=8068 ]

ExternalQActor basicrobot  context ctxbasicrobot
CodedQActor waiterengine context ctxtearoom className "it.unibo.waiterengine.Waiterengine"

QActor waitermind context ctxtearoom{
[#
//	//Coordinates of the entrance door
	val X_Entrancedoor = "0"
	val Y_Entrancedoor = "4"

//	//Coordinates of the exit door
	val X_Exitdoor = "6"
	val Y_Exitdoor = "4"
	
//  //Coordinates of the barman
	val X_servicedesk = "6"
	val Y_servicedesk = "0"	

//	//Coordinates Tables
	val X_teatable1     = "2"
	val Y_teatable1     = "2"

	val X_teatable2     = "4"
	val Y_teatable2     = "2"

	//Coordinates of the home
    val X_home			= "0"
	val Y_home 			= "0"

	val	Cleantime = 2000L
	val Servicetime = 5000L
	val CollectTime = 4000L
	data class Table(var state: String ="cleaned") {
		
	}
	val table1 = Table()
	val table2 = Table()
	var stateTable1 = "cleaned"
	var stateTable2 = "cleaned"
#]
	State s0 initial {
		discardMsg Off
		println("waitermind   |||   init")
		request waiterengine -m start : start(id)
	}
	Transition t0 whenReply ready -> home
	
	State reachhome{
		println("waitermind   |||   reachhome")
		request waiterengine -m moveto : moveto($X_home,$Y_home)
	}
	Transition t0 whenReply done -> home
	
	State home{
		println("waitermind   |||   home")
		updateResource [# "home" #]
	}
	Transition t0 whenRequest enter -> accept
				  whenMsg clientready -> take
				  whenMsg drinkready -> reachBarman
				  whenMsg paymentready -> reachTableCollect
				  whenMsg end -> endwork
	
	State accept {
		println("waitermind   |||   accept")
		replyTo enter with accept : accept(idclient)
	}
	Goto reachEntranceDoor
	
	State reachEntranceDoor {
		println("waitermind   |||   reachEntranceDoor")
		updateResource[# "reachEntranceDoor" #]
		request waiterengine -m moveto : moveto($X_Entrancedoor, $Y_Entrancedoor)
	}
	Transition t0 whenReply done -> convoyToTable
	
	State convoyToTable{
		println("waitermind   |||   convoyToTable")
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
		[# table1.state= "occupied" #]
		println("waitermind   |||   table state occupied")
		updateResource [# "convoyToTable" #]
		delay 5000
	}
	Transition t0 whenReply done -> reachhome
	
	State take{
		println("waitermind   |||   take")
		updateResource [# "take" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> transmit
	
	State transmit{
		println("waitermind   |||   transmit")
		updateResource [# "transmit" #]
		//forward barman -m order : order(payloadArg(0))
	}
	Goto reachhome
	
	State reachBarman{
		println("waitermind   |||   reachBarman")
		updateResource[# "reachBarman" #]
		request waiterengine -m moveto: moveto($X_servicedesk,$Y_servicedesk)
	}
	Transition t0 whenReply done -> serve
	
	State serve{
		println("waitermind   |||   serve")
		updateResource[# "serve" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> reachhome
	
	State reachTableCollect {
		println("waitermind   |||   reachTable")
		updateResource[# "reachTable" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> collect
	
	State reachTableClean {
		println("waitermind   |||   reachTable")
		updateResource[# "reachTable" #]
		request waiterengine -m moveto : moveto ($X_teatable1,$Y_teatable1)
	}
	Transition t0 whenReply done -> clean
	
	State collect {
		println("waitermind   |||   collect")
		updateResource[# "collect" #]
		delayVar CollectTime
	}
	Goto convoyToExitDoor
	
	State convoyToExitDoor{
		println("waitermind   |||   convoyToExitDoor")
		updateResource[# "convoyToExitDoor" #]
		request waiterengine -m moveto : moveto($X_Exitdoor,$Y_Exitdoor)
		[# table1.state = "dirty" #]
		println("waitermind   |||   table state dirty")
		delay 5000
	}
	Transition t0 whenReply done -> reachTableClean
	
	State clean{
		println("waitermind   |||   clean")
		updateResource[# "clean1" #]
		delayVar Cleantime
		[# table1.state = "undirty" #]
		println("waitermind   |||   table state undirty")
	}
	Goto clean2
	
	State clean2{
		println("waitermind   |||   clean2")
		updateResource[# "clean2" #]
		delayVar Cleantime
		[# table1.state = "sanitized" #]
		println("waitermind   |||   table state sanitized")
	}
	Goto clean3
	
	State clean3{
		println("waitermind   |||   clean3")
		updateResource[# "clean3" #]
		delayVar Cleantime
		[# table1.state = "cleaned" #]
		println("waitermind   |||   table state cleaned")
	}
	Goto reachhome
	
	State endwork{
		println("waitermind   |||   end")
		terminate 0
	}
}

</br>
</br>
<em>waiterengine.qak</em>
</br>
</br>
System  -msglog  subtearoom 

Request moveto : moveto(X,Y)
Reply done : done(X,Y)

Request start : start(S)
Reply ready : ready(V)

Request step       : step( TIME )
Reply   stepdone   : stepdone(V)
Dispatch cmd       : cmd(MOVE)
Reply   stepfail   : stepfail(DURATION, CAUSE)

Context ctxsubtearoom ip [ host="127.0.0.1" port=8068 ]
Context ctxbasicrobot     ip [host="localhost"   port=8020] 

ExternalQActor basicrobot  context ctxbasicrobot

QActor waiterengine context ctxsubtearoom {
	[#
		var XP = "0"
		var YP = "0"
		var CurMove = ""
		val inmapname  = "teaRoomExplored" 
		var StepTime    	   = 348L
		val BackTime           = 2 * StepTime / 3
	#]
	State s0 initial{
		discardMsg On
		run itunibo.planner.plannerUtil.initAI() //init planner entity
		run itunibo.planner.plannerUtil.loadRoomMap( inmapname ) 		
		run itunibo.planner.plannerUtil.showCurrentRobotState()	
		println("waiterengine   |||   init")
	}
	Transition t0 whenRequest start -> started
	
	State started{
		println("waiterengine   |||   started")
		replyTo start with ready : ready(waiterengine)
	}
	Goto wait
	
	State wait{
		println("waiterengine   |||   wait")
		
	}
	Transition t0 whenRequest moveto -> planmove
	
	State planmove{
		onMsg( moveto : moveto(X,Y) ){
			[# XP = payloadArg(0)
			   YP = payloadArg(1)			  
			 #]
			println("waiterengine   |||   moveto ($XP,$YP)")
			run itunibo.planner.plannerUtil.planForGoal("$XP","$YP")
		}
	}
	Goto execPlanMove
	
	State execPlanMove{
		[#  CurMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
	}
	Goto execStep if [# CurMove == "w" #] else execMove
	
	State execStep {
		request basicrobot -m step : step( $StepTime  )
	}
	Transition t0   whenReply stepdone   -> stepDone
					whenReply stepfail   -> stepFailed 
	
	State stepDone{
		updateResource [# itunibo.planner.plannerUtil.getMapOneLine() #]
		run itunibo.planner.plannerUtil.updateMap(  "w" )
  	}
	Goto execPlanMove if [# CurMove.length > 0 #] else endSuccess
	
	State stepFailed{
 		println("waiterengine | stepFailed")
		onMsg(stepfail : stepfail(DURATION, CAUSE) ){
			[# val D = payloadArg(0).toLong()  ; val Dt = Math.abs(StepTime-D); val BackT = D/2 #] 
			println("waiterengine stepFail D= $D, BackTime = ${BackTime}")
			if [# D > BackTime #] {    
				forward basicrobot -m cmd : cmd( s )
				delayVar BackTime
				forward basicrobot -m cmd : cmd( h )
			}	
 		}
 	}   
	Goto execPlanMove if [# CurMove.length > 0 #] else endSuccess
	
	State execMove{
		forward basicrobot -m cmd : cmd($CurMove)
 		run itunibo.planner.plannerUtil.updateMap( "$CurMove" )
	}
	Goto execPlanMove if [# CurMove.length > 0 #] else endSuccess
	
	State endSuccess{
		println("waiterengine   |||   endSuccess, curpos=($XP,$YP)")
		run itunibo.planner.plannerUtil.showCurrentRobotState()
		replyTo moveto with done : done($XP,$YP)
	}
	Goto wait
} 

</pre>

</br>
</br>
Per effettuare un test plan è stato necessario introdurre degli stati intermedi e dei messaggi, in modo da "bloccare" il <em>waiter</em> in determinate posizioni. Come
primo test è stato effettuato un controllo sulle posizioni raggiunte dal <em>waiter</em>, in modo tale che coincidessero
con quelle aspettate (per esempio, quando il <em>waiter</em> prende l'ordine dal <em>barman</em>, deve trovarsi nella posizione del servicedesk).
In questo caso il messaggio Dispatch "gohome" sblocca il <em>waiter</em> dalla posizione attuale.
<pre>
class TestWaiterPosition {
	var waitermind            : ActorBasic? = null
	var waiterengine		  : ActorBasic? = null
	//val mqttTest   	      = MqttUtils("test") 
	val initDelayTime     = 1000L
	
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Before
	fun systemSetUp() {
   		kotlin.concurrent.thread(start = true) {
			it.unibo.ctxtearoom.main()
		}
	}

	@After
	fun terminate() {
		println("%%%  TestWaiter terminate ")
	}
	
	fun checkPosition(x: String, y: String){		
		if( waiterengine != null ){
			println(" --- checkHome --- ${waiterengine!!.geResourceRep()}")
			assertTrue( waiterengine!!.geResourceRep() == "($x,$y)")
		}  
	}
	
	@Test
	fun testRobotboundary(){
	 	runBlocking{
 			while( waitermind == null ){
				println("testWaiterPosition waits for waiterengine ... ")
				delay(initDelayTime)  //time for robot to start
				waitermind = it.unibo.kactor.sysUtil.getActor("waitermind")
 			}
			while(waiterengine == null){
				println("testWaiterPosition waits for waiterengine...")
				delay(initDelayTime)
				waiterengine = it.unibo.kactor.sysUtil.getActor("waiterengine")
			}
			
			MsgUtil.sendMsg(MsgUtil.buildRequest("waitermind","enter","enter","waitermind"),waitermind!!)
 			delay(15000)
			checkPosition("0","0")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","clientready","clientready","waitermind"),waitermind!!)
			delay(15000)
			checkPosition("2","2")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","gohome","gohome","waitermind"),waitermind!!)
			delay(8000)
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","drinkready","drinkready","waitermind"),waitermind!!)
			delay(10000)
			checkPosition("6","0")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","gohome","gohome","waitermind"),waitermind!!)
			delay(15000)
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","paymentready","paymentready","waitermind"),waitermind!!)
			delay(15000)
			checkPosition("6","4")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","gohome","gohome","waitermind"),waitermind!!)
			delay(20000)
			MsgUtil.sendMsg("end","end","end",waitermind!!)
 			if( waitermind != null ) waitermind!!.waitTermination()
  		}
	 	println("testWaiterPosition BYE  ")  
	}
}
</pre>
	
Un secondo test plan è quello di controllare che gli stati del tavoli vengano cambiati correttamente, ovvero se durante la fase di <em>clean</em>
il tavolo passa effettivamente dagli stati "dirty", "undirty", "sanitized" e "cleaned".

<pre>
class TestWaiterTableStates {
	var waitermind            : ActorBasic? = null
	//val mqttTest   	      = MqttUtils("test") 
	val initDelayTime     = 1000L
	
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi
	@Before
	fun systemSetUp() {
   		kotlin.concurrent.thread(start = true) {
			it.unibo.ctxtearoom.main()
		}
	}

	@After
	fun terminate() {
		println("%%%  TestWaiter terminate ")
	}
	
	fun checkState(state: String){		
		if(waitermind!=null)
			assert(waitermind!!.geResourceRep()==state)
	}
	
	@Test
	fun testRobotboundary(){
	 	runBlocking{
 			while( waitermind == null ){
				println("testWaiterPosition waits for waitermind ... ")
				delay(initDelayTime)  //time for robot to start
				waitermind = it.unibo.kactor.sysUtil.getActor("waitermind")
 			}
			
			MsgUtil.sendMsg(MsgUtil.buildRequest("waitermind","enter","enter","waitermind"),waitermind!!)
 			delay(25000)
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","clientready","clientready","waitermind"),waitermind!!)
			delay(15000)
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","drinkready","drinkready","waitermind"),waitermind!!)
			delay(10000)
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","paymentready","paymentready","waitermind"),waitermind!!)
			delay(20000)
			checkState("dirty")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","ok","ok","waitermind"),waitermind!!)
			delay(10000)
			checkState("undirty")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","ok","ok","waitermind"),waitermind!!)
			delay(10000)
			checkState("sanitized")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","ok","ok","waitermind"),waitermind!!)
			delay(10000)
			checkState("cleaned")
			MsgUtil.sendMsg(MsgUtil.buildDispatch("waitermind","ok","ok","waitermind"),waitermind!!)
			delay(10000)
			MsgUtil.sendMsg("end","end","end",waitermind!!)
 			if( waitermind != null ) waitermind!!.waitTermination()
  		}
	 	println("testWaiterPosition BYE  ")  
	}
}

</pre>
</div>	

</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">

<img src="../Foto.jpg" alt="mbot" width="20%" height="15%">
<img src="../angelo.jpeg" alt="mbot" width="20%" height="15%">
<img src="../lonza.jpeg" alt="mbot" width="20%" height="15%">
<hr>
Paolo Verdini, 	Angelo Farina, 	Riccardo Turra
<hr>
paolo.verdini@studio.unibo.it, angelo.farina@studio.unibo.it, riccardo.turra@studio.unibo.it


</div> 

</body></html>